[[_undoing]]
=== Undoing Things

At some point you may decide that you've changed your mind and want to undo a change.
We review a few methods for doing so now.
Be careful, because you can't always undo what you undo.
This is one of the few areas in Git where you may lose work if you make a mistake.

One common undo situation is when you commit too early and forget to add some files,
or you mess up your commit message. To try that commit again, run

[source,console]
----
$ git commit --amend
----

If you've made no changes since your last commit (for instance, you run this command immediately after your previous commit), then your staging area will look exactly the same, and all you'll change is your commit message.

The editor starts, containing the commit message from your previous commit.
Editing and saving the message overwrites the previous message.

As an example, if you commit and then realize you forgot to stage a file you wanted to add to the commit, run

[source,console]
----
$ git commit -m 'Initial commit'
$ git add forgotten_file
$ git commit --amend
----

You end up with a single commit -- the second commit replaces the first.

[NOTE]
====
Remember that when you amend your last commit, you're not really fixing it.
Instead you're _replacing_ the old commit entirely with a new commit.
It's as if the previous commit never happened, and it won't be in your repository.

The obvious reason for amending commits is to improve your last commit, without cluttering your repository history with commit messages of the form, ``Oops, forgot to add a file'' or ``Darn, fixing a typo in last commit''.
====

[NOTE]
====
Only amend commits that are still local and have not been pushed to a remote repository.
Amending previously pushed commits will cause problems for your collaborators.
For more on what happens when you do this and how to recover read <<_rebase_peril>>.
====

[[_unstaging]]
==== Unstaging a Staged File

The next two sections demonstrate how to manage your staging area and working directory.
The nice part is that when `git status` shows the state of these areas it also reminds you how to undo changes to them.
For example, let's say you've changed two files and want to save them in two separate commits,
but you accidentally run `git add *` and stage them both. How can you unstage one of them?
`git status` reminds you.

[source,console]
----
$ git add *
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
    modified:   CONTRIBUTING.md
----

Right below the `Changes to be committed:` section, you see `(use "git reset HEAD <file>..." to unstage)`.
So, let's follow that advice to unstage `CONTRIBUTING.md`.

[source,console]
----
$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

The command looks a bit strange, but it works.
The modified version of `CONTRIBUTING.md` remains in the working directory but once again is unstaged.

[NOTE]
=====
`git reset` _can_ be dangerous if you run it with the `--hard` flag because it can change files in your working directory.
However, in the scenario described above, the file in your working directory is not touched.
=====

For now this magic invocation is all you need to know about `git reset`. We go into much more detail about what it does and how to get it to do really interesting things in <<ch07-git-tools#_git_reset>>.

==== Unmodifying a Modified File

What if you realize that you don't want to keep your changes to `CONTRIBUTING.md` in your working directory?
How can you unmodify it -- that is, revert it back to what it looked like before you changed it?
Luckily, `git status` tells you how to do that too.
In the last example, the unstaged output area looks like

[source,console]
----
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

This tells you exactly how to discard the changes you've made.
Let's do what it says.

[source,console]
----
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

----

You can see that the changes have been reverted.

[IMPORTANT]
=====
It's important to understand that `git checkout -- <file>` is a dangerous command. Any local changes you made
to that file in the working directory are gone because
Git just replaced that file with the last staged or committed version.
Don't ever use this command unless you're absolutely sure you no longer want the unsaved local changes.
=====

To keep the changes you've made to a file but get it out of the way for now, read about
stashing and branching in <<ch03-git-branching#ch03-git-branching>>.
There are generally better ways to accomplish this
than resetting.

Remember, anything that is _committed_ in Git can almost always be recovered.
Even commits that were on branches that were deleted or commits that were overwritten with an `--amend` commit can be recovered (see <<ch10-git-internals#_data_recovery>> for data recovery).
However, anything you lose that was never committed is likely never to be seen again.

[[undoing_git_restore]]
==== Undoing things with git restore

Git version 2.23.0 introduced the `git restore` command.
It's basically an alternative to `git reset` for undoing changes.

Let's retrace our steps, and undo things with `git restore` instead of `git reset`.

===== Unstaging a Staged File with git restore

The next two sections demonstrate how to work with changes in your staging area and working directory with `git restore`.
The nice part is that the `git status` command that shows their state also reminds you how to undo changes to them.
For example, let's say you changed two files and want to commit them as two separate changes, but you accidentally type `git add *` and stage them both.
How can you unstage one of the two?
The `git status` command reminds you:

[source,console]
----
$ git add *
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   CONTRIBUTING.md
	renamed:    README.md -> README

----

Right below the "`Changes to be committed`" text, it says use `git restore --staged <file>...` to unstage.
So, let's do that to unstage `CONTRIBUTING.md`.

[source,console]
----
$ git restore --staged CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	renamed:    README.md -> README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   CONTRIBUTING.md

----

`CONTRIBUTING.md` is modified but once again unstaged.

===== Unmodifying a Modified File with git restore

What if you realize that you don't want to keep your changes to `CONTRIBUTING.md`?
How can you unmodify it -- that is revert it back to what it looked like when you last committed (or initially cloned) it?
Luckily, `git status` tells you how to do that, too.

In the last example output, the unstaged area looks like

[source,console]
----
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   CONTRIBUTING.md

----

This tells explicitly tells you how to discard the changes you've made.
Let's do what it says:

[source,console]
----
$ git restore CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	renamed:    README.md -> README

----

[IMPORTANT]
=====
It's important to understand that `git restore <file>` is a dangerous command.
Any local changes you made to that file are gone -- Git just replaced that file with the last staged or committed version.
Don't use this command unless you absolutely know that you don't want those unsaved local changes.
=====
