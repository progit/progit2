=== go-git

(((go-git)))(((Go)))
To integrate Git into a service written in Golang, there's a pure Go library implementation.
This implementation doesn't have any native dependencies and thus isn't prone to manual memory management errors.
It's also transparent to the standard Golang performance analysis tools like CPU, Memory profilers, race detector,
etc.

go-git is focused on extensibility and compatibility, and supports most of the plumbing APIs, which are
documented at https://github.com/src-d/go-git/blob/master/COMPATIBILITY.md[].

Here's a basic example of using Go APIs.

[source, go]
----
import "github.com/go-git/go-git/v5"

r, err := git.PlainClone("/tmp/foo", false, &git.CloneOptions{
    URL:      "https://github.com/go-git/go-git",
    Progress: os.Stdout,
})
----

As soon as you have a `Repository` instance, you can access information and perform mutations on it.

[source, go]
----
// retrieves the branch pointed by HEAD
ref, err := r.Head()

// get the commit object, pointed by ref
commit, err := r.CommitObject(ref.Hash())

// retrieves the commit history
history, err := commit.History()

// iterates over the commits and print each
for _, c := range history {
    fmt.Println(c)
}
----

==== Advanced Functionality

go-git has few notable advanced features, one of which is a pluggable storage system, which is similar to Libgit2 backends.
The default implementation is in-memory storage, which is very fast.

[source, go]
----
r, err := git.Clone(memory.NewStorage(), nil, &git.CloneOptions{
    URL: "https://github.com/go-git/go-git",
})
----

Pluggable storage provides many interesting options.
For instance, https://github.com/go-git/go-git/tree/master/_examples/storage[^] allows you to store references, objects, and configuration in an Aerospike database.

Another feature is a flexible filesystem abstraction.
Using https://pkg.go.dev/github.com/go-git/go-billy/v5?tab=doc#Filesystem[^] it's easy to store all the files in different way, i.e by packing all of them into a single archive on disk or by keeping them all in-memory.

Another advanced use-case includes a fine-tunable HTTP client, such as the one found at https://github.com/go-git/go-git/blob/master/_examples/custom_http/main.go[^].

[source, go]
----
customClient := &http.Client{
    Transport: &http.Transport{ // accept any certificate (might be useful for testing)
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
    },
    Timeout: 15 * time.Second,  // 15 second timeout
        CheckRedirect: func(req *http.Request, via []*http.Request) error {
        return http.ErrUseLastResponse // don't follow redirect
    },
}

// Override http(s) default protocol to use our custom client
client.InstallProtocol("https", githttp.NewClient(customClient))

// Clone repository using the new client if the protocol is https://
r, err := git.Clone(memory.NewStorage(), nil, &git.CloneOptions{URL: url})
----

==== Further Reading

A full treatment of go-git's capabilities is outside the scope of this book.
For more information on go-git, there's API documentation at https://pkg.go.dev/github.com/go-git/go-git/v5[^], and a set of usage examples at https://github.com/go-git/go-git/tree/master/_examples[^].
