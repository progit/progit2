[appendix]
== Εντολές Git

Σε όλο το βιβλίο έχουμε εισάγει δεκάδες εντολές Git και προσπαθήσαμε σκληρά να τις εισάγουμε μέσα σε ένα αφηγηματικό πλαίσιο, προσθέτοντας περισσότερες εντολές στην ιστορία αργά.
Ωστόσο, αυτό μας αφήνει με παραδείγματα χρήσης των εντολών κάπως διάσπαρτα σε όλο το βιβλίο.

Σε αυτό το παράρτημα, θα διαπεράσουμε όλες τις εντολές Git που εξετάσαμε σε όλο το βιβλίο, χονδρικά ομαδοποιημένες με βάση τη χρήση τους.
Θα μιλήσουμε για το τι κάνει γενικά κάθε εντολή και στη συνέχεια να επισημάνουμε πού στο βιβλίο θα βρούμε τις χρήσεις τους.

=== Ρύθμιση και διαμόρφωση

Υπάρχουν δύο εντολές που χρησιμοποιούνται αρκετά, από τις πρώτες επικλήσεις του Git σε κοινές καθημερινές μικροαλλαγές και αναφορές, οι εντολές `config` και `help`.

==== `git config`

Το Git έχει έναν προεπιλεγμένο τρόπο να κάνει εκατοντάδες πράγματα.
Για πολλά από αυτά τα πράγματα, μπορούμε να ενημερώσουμε το Git να τα κάνει με διαφορετικό προεπιλεγμένο τρόπο ή να ορίσουμε τις προτιμήσεις μας.
Αυτό περιλαμβάνει τα πάντα, από το να πούμε στο Git τι είναι το όνομά μας σε συγκεκριμένες προτιμήσεις χρώματος τερματικού ή ποιον επεξεργαστή κειμένου χρησιμοποιούμε.
Υπάρχουν πολλά αρχεία από τα οποία θα διαβάσει και στα οποία θα γράψει αυτή η εντολή, γι' αυτό μπορούμε να ορίσουμε τιμές σε καθολικό επίπεδο ή για συγκεκριμένα αποθετήρια.

Η εντολή `git config` έχει χρησιμοποιηθεί σχεδόν σε κάθε κεφάλαιο του βιβλίου.

Στην ενότητα <<_first_time>> τη χρησιμοποιούμε για να καθορίσουμε το όνομα, τη διεύθυνση e-mail και την προτίμηση μας για τον επεξεργαστή κειμένου προτού καν ξεκινήσουμε να χρησιμοποιούμε το Git.

Στην ενότητα <<_git_aliases>> βλέπουμε πώς μπορούμε να τη χρησιμοποιήσουμε για να δημιουργήσουμε συντομογραφίες εντολών που επεκτείνονται σε μεγάλες ακολουθίες επιλογών, ώστε να μην χρειάζεται να τις πληκτρολογούμε κάθε φορά.

Στην ενότητα <<_rebasing>> τη χρησιμοποιούμε για να κάνουμε `--rebase` την προεπιλογή όταν τρέχουμε την `git pull`.

Στην ενότητα <<_credential_caching>> τη χρησιμοποιούμε για να ρυθμίσουμε ένα προεπιλεγμένο κατάστημα για τους κωδικούς μας HTTP.

Στην ενότητα <<_keyword_expansion>> βλέπουμε πώς να εγκαθιστούμε φίλτρα μουτζουρώματος και καθαρίσματος σε περιεχόμενο που εισέρχεται και εξέρχεται από το Git.

Τέλος, το σύνολο της ενότητας <<_git_config>> είναι αφιερωμένο στην εντολή.

==== `git help`

Η εντολή `git help` χρησιμοποιείται για να μας δείξει όλη την τεκμηρίωση περιέχεται στο Git για οποιαδήποτε εντολή.
Ενώ δίνουμε μια γενική επισκόπηση των περισσότερων από τις πιο δημοφιλείς εντολών σε αυτό το παράρτημα, για μια πλήρη λίστα όλων των πιθανών επιλογών και σημαιών για κάθε εντολή, μπορούμε πάντα να εκτελέσουμε το `git help <εντολή>`.

Βλέπουμε την εντολή `git help` στην ενότητα <<_git_help>> και πώς να τη χρησιμοποιήσουμε για να βρούμε περισσότερες πληροφορίες για την `git shell` στην ενότητα <<_setting_up_server>>.

=== Λήψη και δημιουργία έργων

Υπάρχουν δύο τρόποι για να αποκτήσουμε ένα αποθετήριο Git.
Ο ένας είναι να το αντιγράψουμε από ένα υπάρχον αποθετήριο στο δίκτυο ή αλλού και ο άλλος να δημιουργήσουμε ένα νέο σε έναν υπάρχοντα κατάλογο.

==== `git init`

Για να πάρουμε έναν κατάλογο και να τον μετατρέψουμε σε ένα νέο αποθετήριο Git, ώστε να μπορούμε να ξεκινήσουμε έλεγχο εκδόσεων, μπορούμε απλά να εκτελέσουμε την `git init`.

Αυτό αναφέρεται για πρώτη φορά στην ενότητα <<_getting_a_repo>>, όπου παρουσιάζεται η δημιουργία ενός ολοκαίνουργιου αποθετηρίου στο οποίο θα δουλεύουμε στη συνέχεια.

Μιλάμε εν συντομία για το πώς μπορούμε να αλλάξουμε τον προεπιλεγμένο κλάδο από τον ``master'' στην ενότητα <<_remote_branches>>.

Χρησιμοποιούμε αυτήν την εντολή για να δημιουργήσουμε ένα άδειο κενό αποθετήριο για έναν διακομιστή στην ενότητα <<_bare_repo>>.

Τέλος, βλέπουμε κάποιες λεπτομέρειες του τι πραγματικά κάνει στο παρασκήνιο αυτή η εντολή σκηνές στην ενότητα <<_plumbing_porcelain».

==== `git clone`

Η εντολή `git clone` είναι στην πραγματικότητα ένα περιτύλιγμα που περιέχει πολλές άλλες εντολές.
Δημιουργεί ένα νέο κατάλογο, πηγαίνει σε αυτόν και τρέχει την `git init` για να τον κάνει ένα κενό αποθετήριο Git, προσθέτει ένα απομακρυσμένο αποθετήριο (`git remote add`) στη διεύθυνση URL που του διαβιβάζουμε (εξ ορισμού ονομάζεται `origin`), τρέχει ένα `git fetch` από το απομακρυσμένο αποθετήριο και στη συνέχεια ελέγχει την πιο πρόσφατη υποβολή στον κατάλογο εργασίας μας με την `git checkout`.

Η εντολή `git clone` χρησιμοποιείται σε δεκάδες μέρη σε όλο το βιβλίο, αλλά θα αναφέρουμε μόνον κάποια ενδιαφέροντα από αυτά.

Εισάγεται και εξηγείται στην ενότητα <<_git_cloning>>, στην οποία βλέπουμε μερικά παραδείγματα.

Στην ενότητα <<_git_on_the_server>> εξετάζουμε τη χρήση της επιλογής `--bare` για να δημιουργήσουμε ένα αντίγραφο ενός αποθετηρίου Git χωρίς κατάλογο εργασίας.

Στην ενότητα <<_bundling>> τη χρησιμοποιούμε για να αποσυσκευάσουμε ένα δεματιασμένο αποθετήριο Git.

Τέλος, στην ενότητα <<_cloning_submodules>> μαθαίνουμε την επιλογή `--recursive` για να κάνουμε την κλωνοποίηση ενός αποθετηρίου με υπομονάδες λίγο πιο απλή.

Αν και χρησιμοποιείται σε πολλά άλλα μέρη μέσω του βιβλίου, αυτά είναι τα σημεία που είναι κατά κάποιον τρόπο μοναδικά ή στα οποία χρησιμοποιείται με τρόπους που είναι λίγο διαφορετικοί.


=== Βασική λήψη στιγμιοτύπων

Για τη βασική ροή εργασίας της προσθήκης περιεχομένου στο ενδιάμεσο στάδιο και της υποβολής του στο ιστορικό μας, υπάρχουν μόνο μερικές βασικές εντολές.

==== `git add`

Η εντολή `git add` προσθέτει περιεχόμενο από τον κατάλογο εργασίας στο ενδιάμεσο στάδιο (ή ``ευρετήριο'') για την επόμενη υποβολή.
Όταν εκτελείται η εντολή `git commit`, εκ προεπιλογής εξετάζει μόνον το ενδιάμεσο στάδιο, συνεπώς η `git add` χρησιμοποιείται για να δημιουργήσουμε ακριβώς όπως θέλουμε το επόμενο υποβληθέν στιγμιότυπό μας.

Αυτή η εντολή είναι μια εξαιρετικά σημαντική εντολή στο Git και αναφέρεται ή χρησιμοποιείται δεκάδες φορές σε αυτό το βιβλίο.
Θα καλύψουμε γρήγορα ορισμένες από τις μοναδικές χρήσεις που αναφέρονται.

Αρχικά εισάγουμε και εξηγούμε λεπτομερώς την `git add` στην ενότητα <<_tracking_files>>.

Αναφέρουμε πώς να τη χρησιμοποιήσουμε για την επίλυση συγκρούσεων συγχώνευσης στην ενότητα <<_basic_merge_conflicts>>.

Βλέπουμε πώς να τη χρησιμοποιούμε για να προσθέσουμε στο ενδιάμεσο στάδιο διαδραστικά  αρχεία ή συγκεκριμένα τμήματα τροποποιημένων αρχείων στην ενότητα <<_interactive_staging>>.

Τέλος, την προσομοιώνουμε σε ένα χαμηλό επίπεδο στην ενότητα <<_tree_objects>>, ώστε να πάρουμε μια ιδέα για το τι κάνει στο παρασκήνιο.

==== `git status`

Η εντολή `git status` μάς δείχνει τις διαφορετικές καταστάσεις αρχείων στον κατάλογο εργασίας και το ενδιάμεσο στάδιο μας.
Ποια αρχεία είναι τροποποιημένα αλλά δεν έχουν προστεθεί στο ενδιάμεσο στάδιο και ποια έχουν προστεθεί αλλά δεν έχουν ακόμη υποβληθεί.
Στην κανονική της μορφή, θα μας δείξει επίσης κάποιες βασικές υποδείξεις σχετικά με τον τρόπο μετακίνησης αρχείων μεταξύ αυτών των σταδίων.

Αρχικά καλύπτουμε την `status` στην ενότητα <<_checking_status>>, τόσο σε βασικές όσο και σε απλοποιημένες μορφές.
Αν και τη χρησιμοποιούμε σε όλο το βιβλίο, σχεδόν όλα όσα μπορούμε να κάνουμε με την εντολή `git status` καλύπτονται αυτήν την ενότητα.

==== `git diff`

Η εντολή `git diff` χρησιμοποιείται όταν θέλουμε να δούμε διαφορές μεταξύ οποιωνδήποτε δύο δένδρων.
Αυτή θα μπορούσε να είναι η διαφορά μεταξύ του περιβάλλοντος εργασίας μας και του ενδιάμεσου σταδίου (σκέτη `git diff`), μεταξύ του ενδιάμεσου σταδίου και της τελευταίας μας υποβολής (`git diff --staged`) ή μεταξύ δύο υποβολών (`git diff master branchB`).

Αρχικά εξετάζουμε τις βασικές χρήσεις της `git diff` στην ενότητα <<_git_diff_staged>>, όπου παρουσιάζεται πώς βλέπουμε ποιες αλλαγές έχουν προστεθεί στο ενδιάμεσο στάδιο και ποιες όχι.

Τη χρησιμοποιούμε για να αναζητήσουμε πιθανά σφάλματα λευκών διαστημάτων πριν υποβάλλουμε με την επιλογή `--check` στην ενότητα <<_commit_guidelines>>.

Βλέπουμε πώς να ελέγξουμε πιο αποτελεσματικά τις διαφορές μεταξύ κλάδων με τη σύνταξη `git diff A...B` στην ενότητα <<_what_is_introduced>>.

Τη χρησιμοποιούμε για να φιλτράρουμε τις διαφορές λευκών διαστημάτων με την επιλογή `-b` και πώς να συγκρίνουμε τα διαφορετικά στάδια των συγκρουόμενων αρχείων με τις `--theirs`, `--ours` και `--base` στην ενότητα <<_advanced_merging>>.

Τέλος, τη χρησιμοποιούμε για να συγκρίνουμε αποτελεσματικά τις αλλαγές των υπομονάδων με την επιλογή `--submodule` στην ενότητα <<_starting_submodules>>.

==== `git difftool`

Η εντολή `git difftool` απλά εκκινεί ένα εξωτερικό εργαλείο για να μας δείξει τη διαφορά (diff) ανάμεσα σε δύο δέντρα στην περίπτωση που θέλουμε να χρησιμοποιήσουμε κάποια άλλη εφαρμογή από την ενσωματωμένη εντολή `git diff`.

Την αναφέρουμε μόνο εν συντομία αυτό στην ενότητα <<_git_diff_staged>>.

==== `git commit`

Η εντολή git commit λαμβάνει όλα τα περιεχόμενα του αρχείου που έχουν προστεθεί στο ενδιάμεσο στάδιο με την `git add`, καταγράφει ένα νέο μόνιμο στιγμιότυπο στη βάση δεδομένων και μετά μετακινεί τον δείκτη κλάδου στον τρέχοντα κλάδο σε αυτό.

Τα βασικά της υποβολής καλύπτονται στην ενότητα <<_committing_changes>>.
Εκεί παρουσιάζεται επίσης πώς χρησιμοποιούμε τη σημαία `-a` για να παραλείψουμε το βήμα `git add` στις καθημερινές ροές εργασίας και πώς να χρησιμοποιήσουμε τη σημαία `-m` για να περάσουμε ένα μήνυμα υποβολής στη γραμμή εντολών αντί για την εκκίνηση ενός επεξεργαστή κειμένου.

Στην ενότητα <<_undoing>> καλύπτεται η τροποποίηση της πιο πρόσφατης υποβολής με την την επιλογή `- amend` για να επαναλάβουμε την πιο πρόσφατη υποβολή.

Στην ενότητα <<_git_branches_overview>>, βλέπουμε με περισσότερες λεπτομέρειες τι κάνει `git commit` και γιατί το κάνει με αυτόν τον τρόπο.

Εξετάζουμε πώς υπογράφουμε κρυπτογραφικά υποβολές με τη σημαία `-S` στην ενότητα <<_signing_commits>>.

Τέλος, ρίχνουμε μια ματιά στο τι κάνει η εντολή `git commit` στο παρασκήνιο και πώς εφαρμόζεται πραγματικά στην ενότητα <<_git_commit_objects>>.

==== `git reset`

Η εντολή `git reset` χρησιμοποιείται κυρίως για να ακυρώσει κάτι, όπως μπορούμε να δούμε και από την ίδια τη λέξη.
Μετακινεί τον δείκτη `HEAD` από δω κι από κει και προαιρετικά αλλάζει τον `index` ή τo ενδιάμεσο στάδιο και μπορεί επίσης προαιρετικά να αλλάξει τον κατάλογο εργασίας μας αν χρησιμοποιήσουμε την επιλογή `--hard`.
Η τελευταία επιλογή καθιστά δυνατή την απώλεια της δουλειάς μας με αυτήν την εντολή, εφόσον χρησιμοποιηθεί εσφαλμένα, οπότε καλά θα είναι να την καταλάβουμε σε βάθος πριν τη χρησιμοποιήσουμε.

Ουσιαστικά η απλούστερη χρήση της `git reset` καλύπτεται στην ενότητα <<_unstaging>>, όπου τη χρησιμοποιούμε για να αφαιρέσουμε από το ενδιάμεσο στάδιο ένα αρχείο στο οποίο είχαμε τρέξει την `git add`.

Στη συνέχεια την καλύπτουμε αρκετά λεπτομερώς στην ενότητα <<_git_reset>>, η οποία είναι εξ ολοκλήρου αφιερωμένη σε αυτήν την εντολή.

Χρησιμοποιούμε την `git reset --hard` για να ματαιώσουμε μια συγχώνευση στην ενότητα <<_abort_merge>>, όπου χρησιμοποιούμε επίσης την `git merge --abort`, η οποία είναι λιγάκι σαν ένα περιτύλιγμα της εντολής `git reset`.

==== `git rm`

Η εντολή `git rm` χρησιμοποιείται για την αφαίρεση αρχείων από το ενδιάμεσο στάδιο και τον κατάλογο εργασίας.
Είναι παρόμοια με το `git add` στο ότι προετοιμάζει την κατάργηση ενός αρχείου για την επόμενη υποβολή.

Η εντολή `git rm` καλύπτεται με κάποια λεπτομέρεια στην ενότητα <<_removing_files>>, συμπεριλαμβανομένων των θεμάτων της αναδρομικής αφαίρεσης αρχείων και της αφαίρεσης αρχείων μόνο από το ενδιάμεσο στάδιο αλλά τη διατήρησή τους στον κατάλογο εργασίας με την επιλογή `--cached`.

Η μόνη άλλη διαφορετική χρήση του `git rm` στο βιβλίο είναι στην ενότητα <<_removing_objects>> όπου εν συντομία χρησιμοποιείται και εξηγείται η `--ignore-unmatch` κατά την εκτέλεση της `git filter-branch`, η οποία ουσιαστικά δεν τερματίζει με σφάλμα όταν το το αρχείο που προσπαθούμε να καταργήσουμε δεν υπάρχει.
Αυτό μπορεί να είναι χρήσιμο όταν η εντολή χρησιμοποιείται σε script.

==== `git mv`

Η εντολή `git mv` είναι μια εντολή ευκολίας για να μετακινήσουμε ένα αρχείο και στη συνέχεια εκτελέσουμε την `git add` στο νέο αρχείο και `git rm` στο παλιό αρχείο.

Την αναφέρουμε μόνο εν συντομία στην ενότητα <<_git_mv>>.

==== `git clean`

Η εντολή `git clean` χρησιμοποιείται για τη διαγραφή ανεπιθύμητων αρχείων από τον κατάλογο εργασίας μας.
Αυτό θα μπορούσε να περιλαμβάνει την αφαίρεση παραπροϊόντων μεταγλώττισης (αρχεία .ο) ή αρχείων σύγκρουσης συγχώνευσης.

Καλύπτουμε πολλές από τις επιλογές και τα σενάρια στα οποία μπορούμε να χρησιμοποιήσουμε την εντολή `clean` στην ενότητα <<_git_clean>>.

=== Διακλάδωση και συγχώνευση

Υπάρχουν μόνο μερικές εντολές που υλοποιούν το μεγαλύτερο μέρος της λειτουργικότητας διακλάδωσης και συγχώνευσης στο Git.

==== `git branch`

Η εντολή 'git branch' είναι στην πραγματικότητα ένα εργαλείο διαχείρισης κλάδων.
Μπορεί να απαριθμήσει τους κλάδους που έχουμε, να δημιουργήσει έναν νέο κλάδο, να διαγράψει κλάδους και να μετονομάσοει κλάδους.

Το μεγαλύτερο μέρος του κεφαλαίου <<_git_branching>> είναι αφιερωμένο στην εντολή `branch` και χρησιμοποιείται σε όλο το κεφάλαιο.
Αρχικά παρουσιάζεται στην ενότητα <<_create_new_branch>> και τα περισσότερα από τα χαρακτηριστικά της (εισαγωγή και διαγραφή) αναλύονται στην ενότητα <<_branch_management>>.

Στην ενότητα <<_tracking_branches>> χρησιμοποιούμε την επιλογή `git branch -u` για να δημιουργήσουμε έναν παρακολουθούμενο κλάδο.

Τέλος, στην ενότητα <<_git_refs>> βλέπουμε μερικά από τα πράγματα που κάνει στο παρασκήνιο.

==== `git checkout`

Η εντολή 'git checkout' χρησιμοποιείται για να μεταβούμε από έναν κλάδο σε άλλο και να ελέγξουμε το περιεχόμενο στον κατάλογο εργασίας μας.

XXX The `git checkout` command is used to switch branches and  check content out into your working directory.

Αρχικά συναντάμε την εντολή στην ενότητα <<_switching_branches>> μαζί με την εντολή `git branch`.

Βλέπουμε πώς να το χρησιμοποιήσουμε για να αρχίσουμε να παρακολουθούμε κλάδους με τη σημαία `--track` στην ενότητα <<_tracking_branches>>.

Τη χρησιμοποιούμε για την επανεισαγωγή των συγκρούσεων αρχείων με τhn `--conflict=diff3` στην ενότητα <<_checking_out_conflicts>>.

Βλέπουμε λεπτομερώς τη σχέση της με την `git reset` στην ενότητα <<_git_reset>>.

Τέλος, βλέπουμε κάποιες λεπτομέρειες υλοποίησής της στην ενότητα <<_the_head>>.

==== `git merge`

Το εργαλείο `git merge` χρησιμοποιείται για τη συγχώνευση ενός ή περισσοτέρων κλάδων στον κλάδο στον οποίο έχουμε κάνει checkout.
Στη συνέχεια ωθεί τον τρέχοντα κλάδο στο αποτέλεσμα της συγχώνευσης.

Η εντολή git merge εισάγεται για πρώτη φορά στην ενότητα <<_basic_branching>>.
Παρότι χρησιμοποιείται σε διάφορα σημεία του βιβλίου, υπάρχουν πολύ λίγες παραλλαγές της εντολής `merge` --βασικά η `git merge <κλάδος>` με το όνομα του μόνου κλάδου που θέλουμε να συγχωνεύσουμε.

Καλύψαμε πώς κάνουμε μία συναρμοσμένη (squashed) συγχώνευση, στην οποία το Git συγχωνεύει το έργο, αλλά προσποιείται ότι πρόκειται για μια νέα υποβολή χωρίς να καταγράφει το ιστορικό του κλάδου που συγχωνεύουμε, στο τέλος της ενότητας <<_public_project>>.

Πολλές πληροφορίες για τη διαδικασία και εντολή συγχώνευσης συμπερλιλαμβανομένης της εντολής `-Xignore-space-change' και της σημαίας `--abort`, όσον αφορά στη ματαίωση μίας προβληματικής συγχώνευσης, υπάρχουν στην ενότητα <<_advanced_merging>>.

Μάθαμε πώς να επαληθεύουμε τις υπογραφές πριν τη συγχώνευση αν το έργο μας χρησιμοποιεί την υπογραφή GPG στην ενότητα <<_signing_commits>>.

Τέλος, μάθαμε για τη συγχώνευση υποδέντρων στην ενότητα <<_subtree_merge>>.

==== `git mergetool`

Η εντολή `git mergetool` απλά εκκινεί έναν εξωτερικό βοηθό συγχώνευσης σε περίπτωση που έχουμε προβλήματα με κάποια συγχώνευση στο Git.

Την αναφέρουμε στα γρήγορα στην ενότητα <<_basic_merge_conflicts>> και βλέπουμε λεπτομερώς πώς να υλοποιήσουμε το δικό μας εξωτερικό εργαλείο συγχώνευσης στην ενότητα <<_external_merge_tools>>.

==== `git log`

Η εντολή `git log` χρησιμοποιείται για να δείξει το προσπελάσιμο εγγεγραμμένο ιστορικό ενός έργου από το πιο πρόσφατο στιγμιότυπο υποβολής και πίσω.
Εκ προεπιλογής εμφανίζεται μόνο το ιστορικό του κλάδου στον οποίο βρισκόμαστε, αλλά είναι δυνατό να δοθούν διαφορετικές ή ακόμα και πολλαπλές κεφαλές ή κλάδοι που μπορούμε να διασχίσουμε.
Συχνά χρησιμοποιείται επίσης για την εμφάνιση διαφορών μεταξύ δύο ή περισσοτέρων κλάδων σε επίπεδο υποβολής.

Αυτή η εντολή χρησιμοποιείται σχεδόν σε κάθε κεφάλαιο του βιβλίου για να επιδείξει την ιστορία ενός έργου.

Εισάγουμε την εντολή και την καλύπτουμε σε κάποιο βάθος στην ενότητα <<_viewing_history>>.
Εξετάζουμε τις επιλογές `-p` και `-stat` για να πάρουμε μια ιδέα για το τι εισήχθη σε κάθε υποβολή και τις επιλογές `--pretty` και `--line` για να δούμε την ιστορία πιο συνοπτικά, μαζί με μερικές απλές ημερομηνίες και επιλογές φιλτραρίσματος συγγραφέων.

Στην ενότητα <<_create_new_branch>> τη χρησιμοποιούμε με την επιλογή `--decorate` για να απεικονίσουμε εύκολα τη θέση των δεικτών του κλάδου μας· επίσης χρησιμοποιούμε την επιλογή `--graph` για να δούμε με τι μοιάζουν αποκλίνουσες ιστορίες.

Στις ενότητες <<_private_team>> και <<_commit_ranges>> καλύπτουμε τη σύνταξη `branchA..branchB` της εντολής `git log` για να δούμε ποιες υποβολές είναι μοναδικές σε έναν κλάδο σε σχέση με έναν άλλο κλάδο.
Στην ενότητα <<_commit_ranges>> βλέπουμε ακριβώς αυτό σε αρκετά μεγάλη έκταση.

Στις ενότητες <<_merge_log>> και <<_triple_dot>> καλύπτουμε τη χρήση της μορφής `branchA...branchB` και τη σύνταξη `--left-right` για να δούμε τι υπάρχει σε έναν κλάδο ή τον άλλο αλλά όχι και στους δύο.
Στην ενότητα <<_merge_log>> εξετάζουμε επίσης πώς χρησιμοποιούμε την επιλογή `--merge` για να βοηθήσουμε στην αποσφαλμάτωση συγκρούσεων συγχώνευσης καθώς και την επιλογή `--cc` για να εξετάσουμε τις συγκρούσεις συγχώνευσης υποβολών στο ιστορικό μας.

Στην ενότητα <<_git_reflog>> χρησιμοποιούμε την επιλογή `-g` για να δούμε το reflog του Git μέσα από αυτό το το εργαλείο αντί να κάνουμε διέλευση κλάδων.


Στην ενότητα <<_searching>> εξετάζουμε τις επιλογές `-S` και `-L` για να κάνουμε αρκετά εξεζητημένες αναζητήσεις για κάτι που συνέβη στο παρελθόν στον κώδικα, όπως για παράδειγμα το ιστορικό μιας συνάρτησης.

Στην ενότητα <<_signing_commits>> βλέπουμε πώς χρησιμοποιούμε την `--show-signature` για να προσθέσουμε μια συμβολοσειρά επικύρωσης σε κάθε υποβολή στην έξοδο της `git log` ανάλογα με το αν είναι έγκυρα υπογεγραμμένη ή όχι.

==== `git stash`

Η εντολή `git stash` χρησιμοποιείται για την προσωρινή αποθήκευση εργασιών που δεν έχουν υποβληθεί, προκειμένου να καθαριστεί ο κατάλογος εργασίας μας χωρίς να χρειάζεται να εκτελέσουμε εργασίες που δεν έχουν ολοκληρωθεί σε κάποιον κλάδο.

Καλύπτεται εξ ολοκλήρου στην ενότητα <<_git_stashing>>.

==== `git tag`

Η εντολή `git tag` χρησιμοποιείται για να προσαρτήσει έναν μόνιμο σελιδοδείκτη σε ένα συγκεκριμένο σημείο στο ιστορικό του κώδικα.
Γενικά αυτό χρησιμοποιείται για πράγματα όπως εκδόσεις κυκλοφορίας λογισμικού (release).

Αυτή η εντολή εισάγεται και καλύπτεται λεπτομερώς στην ενότητα <<_git_tagging>> και τη χρησιμοποιούμε στην πράξη στην ενότητα <<_tagging_releases>>.

Καλύπτουμε επίσης τον τρόπο δημιουργίας μιας ετικέτας που έχει υπογραφεί με GPG με τη σημαία `-s` και την επαλήθευση ετικετών με τη σημαία `-v` στην ενότητα <<_signing>>.


=== Κοινή χρήση και ενημέρωση έργων

Δεν υπάρχουν πολλές εντολές στο Git που έχουν πρόσβαση στο δίκτυο, σχεδόν όλες οι εντολές λειτουργούν στην τοπική βάση δεδομένων.
Όταν είμαστε έτοιμοι να μοιραστούμε τη δουλειά μας ή να έλξουμε αλλαγές από αλλού, υπάρχει μια χούφτα εντολών που ασχολούνται με τα απομακρυσμένα αποθετήρια.

==== `git fetch`

Η εντολή `git fetch` επικοινωνεί με ένα απομακρυσμένο αποθετήριο και ανακτά όλες τις πληροφορίες που βρίσκονται σε εκείνο το αποθετήριο που δεν βρίσκονται στο τρέχον αποεθτήριο και τις αποθηκεύει στην τοπική βάση δεδομένων μας.

Αρχικά εξετάζουμε αυτήν την εντολή στην ενότητα <<_fetching_and_pulling>> και συνεχίζουμε να δούμε παραδείγματα χρήσης της στην ενότητα <<_remote_branches>>.

Τη χρησιμοποιούμε επίσης σε πολλά παραδείγματα στην ενότητα <<_contributing_project>>.

Τη χρησιμοποιούμε για να ανακτήσουμε μια συγκεκριμένη αναφορά που βρίσκεται έξω από τον προεπιλεγμένο χώρο στην ενότητα <<_pr_refs>> και βλέπουμε πώς να ανακτήσουμε από ένα δεμάτι στην ενότητα <<_bundling>>.

Δημιουργήσαμε πολύ εξατομικευμένες αναφορές για να κάνουμε την `git fetch` να έχει λίγο διαφορετική λειτουργία από την προεπιλεγμένη στην ενότητα <<_refspec>>.

==== `git pull`

Η εντολή `git pull` είναι βασικά ένας συνδυασμός των εντολών `git fetch` και `git merge`, στον οποίο το Git θα ανακτήσει από το απομακρυσμένο σημείο που καθορίζουμε και στη συνέχεια θα προσπαθήσει αμέσως να το συγχωνεύσει στον κλάδο στον οποίο βρισκόμαστε.

Την εισάγουμε γρήγορα στην ενότητα <<_fetching_and_pulling>> και δείχνουμε πώς θα δούμε τι θα συγχωνευθεί αν την τρέξουμε στην ενότητα <<_inspecting_remote>>.

Βλέπουμε επίσης πώς να τη χρησιμοποιήσουμε για να βοηθήσουμε στην επανατοποθέτηση επανατοποθετήσεων στην ενότητα <<_rebase_rebase>>.

Δείχνουμε πώς να τη χρησιμοποιήσουμε με μια διεύθυνση URL για να έλξουμε αλλαγές με τη μία στην ενότητα <<_checking_out_remotes>>.

Τέλος, αναφέρουμε πολύ γρήγορα ότι μπορούμε να χρησιμοποιήσουμε την επιλογή `-verify-signatures` για να επαληθεύσουμε ότι οι υποβολές που έχουμε έλξει έχουν υπογραφεί με GPG στην ενότητα <<_signing_commits>>.

==== `git push`

Η εντολή `git push` χρησιμοποιείται για να επικοινωνήσουμε με ένα άλλο αποθετήριο, να υπολογίσουμε τι έχει η τοπική βάση δεδομένων μας που δεν το έχει το απομακρυσμένο αποθετήριο και στη συνέχεια ωθεί τη διαφορά στο άλλο αποθετήριο.
Απαιτεί πρόσβαση εγγραφής στο άλλο αποθετήριο, συνεπώς εμπλέκει κάποιου είδους ταυτοποίηση.

Αρχικά εξετάζουμε την εντολή `git push` στην ενότητα <<_pushing_remotes>>, στην οποία καλύπτουμε τα βασικά στοιχεία της ώθησης ενός κλάδου σε ένα απομακρυσμένο αποθετήριο.
Στην ενότητα <<_pushing_branches>> προχωρούμε λίγο πιο βαθιά στην ώθηση συγκεκριμένων κλάδων και στην ενότητα <<_tracking_branches>> βλέπουμε πώς μπορούμε να ρυθμίσουμε παρακολουθούμενος κλάδους ώστε να ωθούμε σε αυτούς αυτόματα.
Στην ενότητα <<_delete_branches>> χρησιμοποιούμε τη σημαία `--delete` για να διαγράψουμε έναν κλάδο στον διακομιστή με την `git push`.

Σε όλη την ενότητα <<_contributing_project>> βλέπουμε αρκετά παραδείγματα χρήσης της `git push` για να μοιραζόμαστε την εργασία σε κλάδους σε πολλά αποθετήρια.

Βλέπουμε πώς να τη χρησιμοποιούμε για να μοιραζόμαστε τις ετικέτες που έχουμε φτιάξει με την επιλογή `--tags` στην ενότητα <<_sharing_tags>>.

Στην ενότητα <<_publishing_submodules>> χρησιμοποιούμε την επιλογή `--recurse-submodules` για να ελέγξουμε ότι όλα τα submodules μας έχουν δημοσιευθεί πριν ωθήσουμε το superproject, κάτι που μπορεί να είναι πραγματικά χρήσιμο όταν χρησιμοποιούμε submodules.

Στην ενότητα <<_other_client_hooks>> μιλάμε εν συντομία για το άγκιστρο `pre-push`, το οποίο είναι ένα script που μπορούμε να ρυθμίσουμε να τρέχει πριν ολοκληρωθεί η ώθηση για να επιβεβαιωθεί ότι επιτρέπεται να ωθηθεί.

Τέλος, στην ενότητα <<_pushing_refspecs>> εξετάζουμε την ώθηση με πλήρη refspec αντί για τις γενικές συντομεύσεις που χρησιμοποιούνται κανονικά.
Αυτό μπορεί να μας βοηθήσει να είμαστε πολύ συγκεκριμένοι σχετικά με το έργο που θέλουμε να μοιραστούμε.

==== `git remote`

Η εντολή `git remote` είναι ένα εργαλείο διαχείρισης των απομακρυσμένων αποθετηρίων μας.
Μας επιτρέπει να αποθηκεύουμε μεγάλες διευθύνσεις URL ως σύντομα ψευδόνυμα, όπως ``origin'', ώστε να μην χρειάζεται να τις πληκτρολογούμε συνεχώς.
Μπορούμε να έχουμε αρκετές τέτοιες και η εντολή `git remote` χρησιμοποιείται για την προσθήκη, αλλαγή και διαγραφή τους.

Αυτή η εντολή καλύπτεται λεπτομερώς στην ενότητα <<_remote_repos>>, συμπεριλαμβανομένης της καταχώρισης, προσθήκης, αφαίρεσης και της μετονομασίας των απομακρυσμένων αποθετηρίων.

Χρησιμοποιείται σχεδόν σε κάθε επόμενο κεφάλαιο του βιβλίου, αλλά πάντα στο τυπικό σχήμα `git remote add <όνομα> <url>`.

==== `git archive`

Η εντολή `git archive` χρησιμοποιείται για τη δημιουργία ενός αρχείου αρχειοθήκης ενός συγκεκριμένου στιγμιότυπου του έργου.

Χρησιμοποιούμε το `git archive` για να δημιουργήσουμε ένα tarball ενός έργου για κοινή χρήση στην ενότητα <<_preparation_release>>.

==== `git submodule`

Η εντολή `git submodule` χρησιμοποιείται για τη διαχείριση εξωτερικών αποθετηρίων μέσα σε ένα κανονικό αποθετήριο.
Αυτό θα μπορούσε να γίνεται π.χ. για βιβλιοθήκες ή άλλους τύπους κοινών πόρων.
Η εντολή `submodule` έχει πολλές υπό-εντολές (` add`, `update`, `sync`, κ.λπ.) για τη διαχείριση αυτών των πόρων.

Αυτή η εντολή αναφέρεται και καλύπτεται εξ ολοκλήρου στην ενότητα <<_git_submodules>>.

=== Επιθεώρηση και σύγκριση

==== `git show`

Η εντολή git show μπορεί να εμφανίσει ένα αντικείμενο Git με έναν απλό και αναγνώσιμο από ανθρώπους τρόπο.
Κανονικά θα τη χρησιμοποιούσαμε για να εμφανίσουμε πληροφορίες σχετικές με μια ετικέτα ή μια υποβολή.

Αρχικά τη χρησιμοποιούμε για την εμφάνιση επισημειωμένων πληροφοριών ετικετών στην ενότητα <<_annotated_tags>>.

Αργότερα το χρησιμοποιούμε αρκετά στην ενότητα <<_revision_selection>> για να δείξουμε τις υποβολές τις οποίες επιλύουν οι διάφορες επιλογές αναθεωρήσεών μας.

One of the more interesting things we do with `git show` is in <<_manual_remerge>> to extract specific file contents of various stages during a merge conflict.

Ένα από τα πιο ενδιαφέροντα πράγματα που κάνουμε με την `git show` είναι να εξάγουμε συγκεκριμένα περιεχόμενα αρχείου σε διάφορα στάδια κατά τη διάρκεια μιας σύγκρουσης συγχώνευσης (ενότητα <<_manual_remerge>>).

==== `git shortlog`

Η εντολή `git shortlog` χρησιμοποιείται για να συνοψίσει την έξοδο της `git log`.
Πολλές από τις επιλογές που παίρνει είναι ίδιες με αυτές που παίρνει η εντολή `git log`, αλλά αντί να αναγράφει όλες τις υποβολές, παρουσιάζει μια σύνοψη των υποβολών, ομαδοποιημένων ανά συντάκτη.

Η χρήση της για τη δημιουργία ενός ωραιότατου μητρώου αλλαγών (changelog) περιγράφεται στην ενότητα <<_the_shortlog>>.

==== `git describe`

Η εντολή `git describe` χρησιμοποιείται για να πάρει ο,τιδήποτε επιλύεται σε μια υποβολή και παράγει μια συμβολοσειρά που είναι σχετικά αναγνώσιμη από ανθρώπους και δεν θα αλλάζει.
Είναι ένας τρόπος για να αποκτήσουμε μια περιγραφή κάποιας υποβολής που είναι τόσο μονοσήματνη όσο ο αριθμός SHA-1 μίας υποβολής αλλά πιο κατανοητή.

Χρησιμοποιούμε την `git describe` στις ενότητες <<_build_number>> και <<_preparing_release>> για να πάρουμε μια συμβολοσειρά με την οποία ονομάζουμε μία δημοσιευμένη έκδοση στη συνέχεια.


=== Αποσφαλμάτωση

Το Git έχει μερικές εντολές που χρησιμοποιούνται για την αποσφαλμάτωση προβλημάτων στον κώδικά μας.
Αυτό κυμαίνεται ανάμεσα στο να ανακαλύψουμε πού εισήχθη κάτι μέχρι στο ποιος το εισήγαγε.

==== `git bisect`

Το εργαλείο `git bisect` είναι ένα απίστευτα χρήσιμο εργαλείο εντοπισμού σφαλμάτων που χρησιμοποιείται για να εντοπίσει ποια συγκεκριμένη υποβολή ήταν η πρώτη που εισήγαγε ένα σφάλμα ή πρόβλημα κάνοντας μια αυτόματη δυαδική αναζήτηση.

Καλύπτεται πλήρως στην ενότητα <<_binary_search>> που είναι και η μόνη ενότητα στην οποία αναφέρεται.

==== `git blame`

Η εντολή `git blame` επισημειώνει τις γραμμές κάθε αρχείου με την τελευταία υποβολή στην οποία εισήχθη αλλαγή σε αυτήν τη γραμμή και ποιος έκανε αυτήν την αλλαγήου ο οποίο η τελευταία ήταν η εισαγωγή για να εισαγάγει μια αλλαγή σε κάθε γραμμή του αρχείου και ποιο πρόσωπο που συνέταξε αυτό που διαπράττει.
Αυτό είναι χρήσιμο για να βρούμε το άτομο και να του ζητήσουμε περισσότερες πληροφορίες σχετικά με ένα συγκεκριμένο τμήμα του κώδικά μας.

Καλύπτεται στην ενότητα <<_file_annotation>> και αναφέρεται μόνο σε αυτήν την ενότητα.

==== `git grep`

Η εντολή `git grep` μπορεί να μας βοηθήσει να βρούμε οποιαδήποτε συμβολοσειρά ή κανονική έκφραση (regular expression) σε οποιοδήποτε από τα αρχεία του πηγαίου κώδικα μας, ακόμα και παλαιότερες εκδόσεις του έργου μας.

Καλύπτεται στην ενότητα <<_git_grep>> και αναφέρεται μόνο σε αυτήν την ενότητα.

=== Επιθέματα

Ορισμένες εντολές στο Git επικεντρώνονται στην έννοια της αντιληψης των υποβολών ως εισαγόμενων αλλαγών σαν μία σειρά από υποβολές να είναι μία σειρά από επιθέματα.
Αυτές οι εντολές μας βοηθούν να διαχειριστούμε τους κλάδους μας με αυτόν τον τρόπο.

==== `git cherry-pick`

Η εντολή `git cherry-pick` χρησιμοποιείται για να πάρει την αλλαγή που εισήχθη σε μια μοναδική υποβολή και να προσπαθήσει να την επαναλάβει ως νέα υποβολή για τον κλάδο στο οποίο βρισκόμαστε.
Αυτό μπορεί να είναι χρήσιμο όταν θέλουμε να πάρουμε μόνο μία ή δύο υποβολές από έναν κλάδο αντί να συγχωνεύσουμε τον κλάδο, κάτι που θα επιτελέσει όλες τις αλλαγές.

Η ανθολόγηση περιγράφεται και παρουσιάζεται στην ενότητα <<_rebase_cherry_pick>>.

==== `git rebase`

Η εντολή `git rebase` είναι βασικά μια αυτοματοποιημένη ανθολόγηση.
Προσδιορίζει μια σειρά υποβολών και στη συνέχεια τις ανθολογεί μία μία σειρά με την ίδια σειρά κάπου αλλού.

Η επανατοποθέτηση καλύπτεται λεπτομερώς στην ενότητα << rebasing>>, συμπεριλαμβανομένων συνεργατικών ζητημάτων που σχετίζονται με την επανατοποθέτηση κλάδων που είναι ήδη δημόσιοι.

Τη χρησιμοποιούμε πρακτικά σε ένα παράδειγμα διαίρεσης του ιστορικού μας σε δύο χωριστά αποθετήρια στην ενότητα <<_replace>> στο οποίο χρησιμοποιούμε επίσης τη σημαία `--onto`.

Στην ενότητα <<_rerere>> αντιμετωπίζουμε μια σύγκρουση συγχώνευσης κατά τη διαδικασία επανατοποθέτησης.

Επίσης, τη χρησιμοποιούμε στην ενότητα <<_changing_multiple>> σε μια διαδραστική λειτουργία script με την επιλογή `-i`.

==== `git revert`

Η εντολή `git revert` είναι ουσιαστικά η αντίστροφη της `git cherry-pick`.
Δημιουργεί μια νέα υποβολή που εφαρμόζει το ακριβώς αντίθετο από την αλλαγής που εισήχθη στην υποβολή που στοχεύουμε, ουσιαστικά αναιρόντας ή επαναφέροντάς την.

Τη χρησιμοποιούμε στην ενότητα <<_reverse_commit>> για να αναιρέσουμε μια υποβολή συγχώνευσης.

=== Ηλεκτρονικό ταχυδρομείο

Πολλά έργα Git, συμπεριλαμβανομένου του ίδιου του Git, διατηρούνται εξ ολοκλήρου σε λίστες ηλεκτρονικής αλληλογραφίας.
Το Git διαθέτει πολλά ενσωματωμένα εργαλεία που συμβάλλουν στη διευκόλυνση αυτής της διαδικασίας, από τη δημιουργία επιθεμάτων που μπορούμε να στείλουμε εύκολα με e-mail στην εφαρμογή αυτών των επιθεμάτων από e-mail.

==== `git apply`

Η εντολή `git apply` εφαρμόζει ένα επίθεμα που δημιουργήθηκε με την εντολή `git diff` ή ακόμα και την diff της GNU.
Είναι παρόμοια με αυτό που κάνει η εντολή `patch` (υπάρχουν κάποιες μικρές αλλαγές).

Η χρήση της καθώς και οι περιστάσεις στις οποίες μπορούμε να το κάνουμε παρουσιάζονται στην ενότητα <<_patches_from_email>>.

==== `git am`

Η εντολή `git am` χρησιμοποιείται για την εφαρμογή επιθεμάτων από τα εισερχόμενα e-mail, και πιο συγκεκριμένα το οποίο είναι μορφοποιημένο σαν mbox.
Αυτό είναι χρήσιμο για τη λήψη ενημερωμένων εκδόσεων μέσω e-mail και την εύκολη εφαρμογή τους στο έργο μας.

Καλύψαμε τη χρήση και τη ροή εργασίας γύρω από την `git am` στην ενότητα <<_git_am>>, συμπεριλαμβανομένων των επιλογών `--resolved`, `-i` και `-3`.

Υπάρχει επίσης ένας αριθμός αγκίστρων που μπορούμε να χρησιμοποιούμε για να βοηθήσουμε στη ροή εργασίας γύρω από την `git am`, που καλύπτονται στην ενότητα <<_email_hooks>>.

Επίσης, τη χρησιμοποιούμε για να εφαρμόσουμε αλλαγές σε αιτήματα έλξης στο GitHub, μορφοποιημένες σαν επιθέματα στην ενότητα <<_email_notifications>>.

==== `git format-patch`

Η εντολή `git format-patch` χρησιμοποιείται για τη δημιουργία μιας σειράς επιθεμάτων σε μορφή mbox, που μπορούμε να αποστείλουμε σε μια λίστα αλληλογραφίας, εφόσον είναι κατάλληλα μορφοποιημένη.

Βλέπουμε ένα παράδειγμα συμβολής σε ένα έργο χρησιμοποιώντας το εργαλείο `git format-patch` στην ενότητα <<_project_over_email>>.

==== `git imap-send`

Η εντολή git imap-send μεταφορτώνει ένα γραμματοκιβώτιο που δημιουργείται με την `git format-patch` σε ένα φάκελο προχείρων IMAP.

Ένα παράδειγμα συμβολής σε ένα έργο με αποστολή επιθεμάτων με το εργαλείο `git imap-send` παρουσιάζεται στην ενότητα <<_project_over_email>>.

==== `git send-email`

Η εντολή `git send-email` χρησιμοποιείται για την αποστολή patches που δημιουργούνται με το `git format-patch` μέσω email.

Ένα παράδειγμα συμβολής σε ένα έργο με αποστελή επιθεμάτων με το εργαλείο `git send-email` παρουσιάζεται στην ενότητα <<_project_over_email>>.

==== `git request-pull`

Η εντολή `git request-pull` χρησιμοποιείται απλά για να δημιουργήσουμε ένα σώμα κειμένου e-mail σε κάποιον.
Αν έχουμε έναν κλάδο σε δημόσιο διακομιστή και θέλουμε να ενημερώσουμε κάποιον πώς να ενσωματώσει αυτές τις αλλαγές χωρίς να του στείλουμε τα επιθέματα με e-mail, μπορούμε να εκτελέσουμε αυτήν την εντολή και να στείλουμε την έξοδο στο άτομο που θέλουμε να έλξει τις αλλαγές.

Ο τρόπος χρήσης της `git request-pull` για τη δημιουργία ενός μηνύματος έλξης παρουσιάζεται στην ενότητα <<_public_project>>.

=== Εξωτερικά Συστήματα

Το Git συνοδεύεται από μερικές εντολές για ενσωμάτωση με άλλα συστήματα ελέγχου έκδοσεων.

==== `git svn`

Η εντολή `git svn` χρησιμοποιείται για να επικοινωνήσουμε με το σύστημα ελέγχου έκδοσεων Subversion ως πελάτες.
Αυτό σημαίνει ότι μπορούμε να χρησιμοποιήσουμε το Git για να κάνουμε checkout και να υποβάλλουμε σε διακομιστή Subversion.

Αυτή η εντολή καλύπτεται σε βάθος στην ενότητα <<_git_svn>>.

==== `git fast import`

Για άλλα συστήματα ελέγχου εκδόσεων ή για εισαγωγή από σχεδόν οποιαδήποτε μορφή, μπορούμε να χρησιμοποιήσουμε τη λειτουργία `git fast import` για να απεικονίσουμε γρήγορα την άλλη μορφή σε κάτι που η Git μπορεί εύκολα να καταγράψει.

Αυτή η εντολή καλύπτεται σε βάθος στην ενότητα <<_custom_importer>>.

=== Διοίκηση

Εάν διαχειριζόμαστε ένα αποθετήριο Git ή χρειάζεται να διορθώσουμε κάποια πράγματα σε μεγάλη έκταση, το Git μάς παρέχει μια σειρά διοικητικών εντολών για να μας βοηθήσει.

==== `git gc`
 
Αυτή η εντολή εκτελείται κανονικά στο παρασκήνιο για εμάς, αν και μπορούμε να την εκτελέσουμε χειροκίνητα εάν το επιθυμούμε.
Μερικά παραδείγματα αυτού παρουσιάζονται στην ενότητα <<_git_gc>>.

==== `git fsck`

Η εντολή `git fsck` χρησιμοποιείται για να ελέγξει την εσωτερική βάση δεδομένων για προβλήματα ή ανακολουθίες.

Τη χρησιμοποιούμε μόνο μία φορά στην ενότητα <<_data_recovery>> για να αναζητήσουμε αντικείμενα που εκκρεμούν.

==== `git reflog`

Η εντολή `git reflog` περνάει μέσα από ένα μητρώο στο οποίο καταγράφονται οι θέσεις των κεφαλών των κλάδων μας, ώστε να βρει υποβολές που ενδεχομένως έχουμε χάσει εξαιτίας επανεγγραφής του ιστορικού.

Καλύπτουμε αυτήν την εντολή κυρίως στην ενότητα <<_git_reflog>>, όπου δείχνουμε την κανονική χρήση και πώς χρησιμοποιήσουμε το `git log -g` για να δούμε τις ίδιες πληροφορίες με αυτές που δίνει η έξοδος της `git log`.

Επίσης βλέπουμε ένα πρακτικό παράδειγμα ανάκτησης ενός τέτοιου χαμένου κλάδου στην ενότητα <<_data_recovery>>.

==== `git filter`-branch`

Η εντολή 'git filter-branch` χρησιμοποιείται για να ξαναγράψει πολλές υποβολές σύμφωνα με ορισμένα μοτίβα, όπως η αφαίρεση ενός αρχείου από παντού ή το φιλτράρισμα ολόκληρου του αποθετηρίου σε έναν μόνο υποκατάλογο για την εξαγωγή του έργου.

Στην ενότητα <<_removing_file_every_commit>> εξηγούμε την εντολή και εξερευνούμε διάφορες επιλογές όπως `--commit-filter`, `--subdirectory-filter` και `--tree-filter`.

Στις ενότητες <<_git_p4>> και <<_git_tfs>> τη χρησιμοποιούμε για να διορθώσουμε εισαγόμενα εξωτερικά αποθετήρια.

=== Εντολές διοχέτευσης

Υπάρχουν επίσης αρκετές εντολές διοχέτευσης χαμηλότερου επιπέδου που συναντήσαμε στο βιβλίο.

Η πρώτη είναι η `ls-remote` στην ενότητα <<_pr_refs>> την οποίο χρησιμοποιούμε για να δούμε τις ανεπεξέργαστες αναφορές στον διακομιστή.

Χρησιμοποιούμε την `ls-files` στις ενότητες <<_manual_remerge>>, << rerere>> και << the_index>> για να ρίξουμε μια πιο ακατέργαστη ματιά σε αυτό που είναι το ενδιάμεσο στάδιο.

Επίσης, αναφέρουμε την `rev-parse` στην ενότητα <<_branch_references>> για να πάρουμε σχεδόν οποιαδήποτε συμβολοσειρά και να τη μετατρέψουμε σε αντικείμενο SHA-1.

Ωστόσο, οι περισσότερες από τις εντολές διοχέτευσης χαμηλού επιπέδου που καλύπτουμε είναι στο κεφάλαιο <<_git_internals>>, και αυτές είναι λίγο πολύ αυτό το επίκεντρο αυτού του κεφαλαίου.
Η χρήση τους σε όλο το υπόλοιπο βιβλίο έχει αποφευχθεί σε μεγάλο βαθμό.
