[[r_git_svn]]
==== Git and Subversion

(((Subversion)))(((διαλειτουργικότητα με άλλα VCS, Subversion)))
Ένα μεγάλο μέρος των έργων ανάπτυξης ανοιχτού κώδικα και ένας μεγάλος αριθμός εταιρικών έργων χρησιμοποιεί το Subversion για τη διαχείριση του πηγαίου κώδικα.
Το Subversion υπάρχει εδώ και περισσότερα από 10 χρόνια και για το μεγαλύτερο μέρος της εποχής εκείνης υπήρξε η _de facto_ επιλογή ενός VCS για έργα ανοιχτού κώδικα.
Είναι επίσης πολύ παρόμοια με πολλούς τρόπους με το CVS, το οποίο ήταν ο μεγάλος παίκτης του ελέγχου πηγαίου κώδικα πριν από αυτό.

(((εντολές git, svn)))(((git-svn)))
Ένα από τα εξαιρετικά χαρακτηριστικά του Git είναι μια αμφίδρομη γέφυρα με το Subversion που ονομάζεται `git svn`.
Αυτό το εργαλείο μάς επιτρέπει να χρησιμοποιούμε το Git ως έγκυρο πελάτη σε έναν διακομιστή Subversion, ώστε να μπορούμε να χρησιμοποιήσουμε όλες τις τοπικές λειτουργίες του Git και στη συνέχεια να ωθήσουμε σε έναν διακομιστή Subversion σαν να χρησιμοποιούσαμε το Subversion τοπικά.
Αυτό σημαίνει ότι μπορούμε να κάνουμε τοπικά διακλάδωση και συγχώνευση, να χρησιμοποιήσουμε το στάδιο καταχώρισης, να χρησιμοποιήσουμε την αλλαγή βάσης και την ανθολόγηση κ.ο.κ., ενώ οι συνεργάτες μας συνεχίζουν να εργάζονται με τους σκοτεινούς και αρχαίους τρόπους τους.
Είναι ένας καλός τρόπος να περάσουμε αθόρυβα το Git στο εταιρικό περιβάλλον και να βοηθήσουμε τους συνεργάτες μας να γίνουν πιο αποδοτικοί ενώ εμείς ασχολούμαστε να ασκούμε παρασκηνιακές πιέσεις ώστε να αλλάξουμε τις υποδομές ώστε να υποστηρίζουν το Git πλήρως.
Η γέφυρα Subversion είναι το ναρκωτικό-προθάλαμος στον κόσμο του DVCS.

===== `git svn`

Η βασική εντολή στο Git για όλες τις εντολές γεφύρωσης με το Subversion είναι η `git svn`.
Χρειάζονται αρκετές υποεντολές, επομένως θα δείξουμε τις πιο κοινές ενώ βλέπουμε και μερικές απλές ροές εργασίας.

Είναι σημαντικό να σημειώσουμε ότι όταν χρησιμοποιούμε την `git svn`, αλληλεπιδράμε με το Subversion, το οποίο είναι ένα σύστημα που λειτουργεί πολύ διαφορετικά από το Git.
Παρόλο που *μπορούμε* να κάνουμε τοπικά διακλαδώσεις και συγχωνεύσεις, είναι γενικά καλύτερα να διατηρήσουμε το ιστορικό μας κατά το δυνατόν γραμμικό, αλλάζοντας τη βάση του έργου μας και αποφεύγοντας να κάνουμε πράγματα όπως να αλληλεπιδρούμε ταυτόχρονα με ένα απομακρυσμένο αποθετήριο Git.

Δεν πρέπει να ξαναγράφουμε το ιστορικό μας και μετά να ωθούμε, ούτε να ωθούμε παράλληλα σε κάποιο αποθετήριο Git για να συνεργαζόμαστε με  συνεργάτες προγραμματιστές σε Git.
Το Subversion μπορεί να έχει μόνον ένα γραμμικό ιστορικό και το να το μπερδέψουμε είναι πολύ εύκολο.
Αν εργαζόμαστε μέσα σε μια ομάδα και κάποιοι χρησιμοποιούν το SVN και άλλοι χρησιμοποιούν το Git, πρέπει να βεβαιωθούμε ότι όλοι χρησιμοποιούν τον διακομιστή SVN για να συνεργαστούν --αυτό θα κάνει τη ζωή μας ευκολότερη.

===== Εγκατάσταση

Για να επιδείξουμε αυτήν τη λειτουργικότητα, χρειαζόμαστε ένα τυπικό αποθετήριο SVN στο οποίο έχουμε πρόσβαση εγγραφής.
Για να αντιγράψουμε αυτά τα παραδείγματα, θα πρέπει να δημιουργήσουμε ένα αντίγραφο της δοκιμαστικής αποθήκης.
Για να γίνει αυτό εύκολα, μπορούμε να χρησιμοποιήσουμε ένα εργαλείο που ονομάζεται `svnsync` που συνοδεύει το Subversion.
Για αυτές τις δοκιμές δημιουργήσαμε ένα νέο αποθετήριο Subversion στο Google Code το οποίο ήταν ένα μερικό αντίγραφο του έργου `protobuf`, το οποίο είναι ένα εργαλείο που κωδικοποιεί δομημένα δεδομένα για μετάδοση στο δίκτυο.

Πρέπει πρώτα να δημιουργήσουμε ένα νέο τοπικό αποθετήριο Subversion:

[source,console]
----
$ mkdir /tmp/test-svn
$ svnadmin create /tmp/test-svn
----

Στη συνέχεια, επιτρέπουμε σε όλους τους χρήστες να αλλάξουν revprops --ο εύκολος τρόπος είναι να προσθέσουμε ένα σενάριο `pre-revprop-change` που πάντα τερματίζει με 0:

[source,console]
----
$ cat /tmp/test-svn/hooks/pre-revprop-change
#!/bin/sh
exit 0;
$ chmod +x /tmp/test-svn/hooks/pre-revprop-change
----

Τώρα μπορούμε να συγχρονίσουμε αυτό το έργο με το τοπικό μας μηχάνημα καλώντας την `svnsync init` με τα αποθετήρια από και προς.

[source,console]
----
$ svnsync init file:///tmp/test-svn \
  http://progit-example.googlecode.com/svn/
----

Αυτό ρυθμίζει τις ιδιότητες για την εκτέλεση του συγχρονισμού.
Στη συνέχεια μπορούμε να κλωνοποιήσουμε τον κώδικα εκτελώντας:

[source,console]
----
$ svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .............................[...]
Committed revision 2.
Copied properties for revision 2.
[…]
----

Παρόλο που η λειτουργία αυτή μπορεί να διαρκέσει μόνο λίγα λεπτά, αν προσπαθήσουμε να αντιγράψουμε τον αρχικό αποθετήριο σε ένα άλλο απομακρυσμένο αντί για ένα τοπικό αποθετήριο, η διαδικασία θα διαρκέσει περίπου μία ώρα, παρότι υπάρχουν λιγότερες από 100 υποβολές.
Το Subversion πρέπει να κλωνοποιεί μια αναθεώρηση κάθε φορά και στη συνέχεια να την ωθεί ξανά σε ένα άλλο αποθετήριο -είναι γελοία αναποτελεσματικό, αλλά είναι ο μόνος εύκολος τρόπος για να το κάνουμε.

===== Ξεκίνημα

Τώρα που έχουμε ένα αποθετήριο Subversion στο οποίο έχουμε πρόσβαση εγγραφής, μπορούμε να περάσουμε από μια τυπική ροή εργασίας.
Θα ξεκινήσουμε με την εντολή `git svn clone`, η οποία εισάγει ένα ολόκληρο αποθετήριο Subversion σε ένα τοπικό αποθετήριο Git.
Ας θυμηθούμε ότι αν εισάγουμε από ένα πραγματικό αποθετήριο Subversion, θα πρέπει να αντικαταστήσουμε εδώ την `file:///tmp/test-svn` που υπάρχει εδώ με τη διεύθυνση URL του αποθετηρίου Subversion:

[source,console]
----
$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)
    A	m4/acx_pthread.m4
    A	m4/stl_hash.m4
    A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java
    A	java/src/test/java/com/google/protobuf/WireFormatTest.java
…
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)
Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/my-calc-branch, 75
Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae
Following parent with do_switch
Successfully followed parent
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)
Checked out HEAD:
  file:///tmp/test-svn/trunk r75
----

Η παραπάνω εκτελεί το ισοδύναμο δύο εντολών --`git svn init` ακολουθούμενη από την `git svn fetch`-- στη διεύθυνση URL που παρέχουμε.
Αυτό ίσως διαρκέσει λίγο.
Το δοκιμαστικό έργο έχει μόνο περίπου 75 υποβολές και η βάση του κώδικα  δεν είναι τόσο μεγάλη, αλλά το Git πρέπει να ελέγχει κάθε έκδοση μία μία και να την υποβάλει ξεχωριστά.
Για ένα έργο με εκατοντάδες ή χιλιάδες υποβολές, αυτό μπορεί να πάρει κυριολεκτικά ώρες ή ακόμα και ημέρες για να ολοκληρωθεί.

Το τμήμα 
The `-T trunk -b branches -t tags` λέει στο Git ότι αυτό το αποθετήριο Subversion ακολουθεί τις βασικές συμβάσεις διακλάδωσης και σήμανσης με ετικέτες.
Εάν ονομάσουμε τον κορμό, τους κλάδους ή τις ετικέτες διαφορετικά,  μπορούμε να αλλάξουμε αυτές τις επιλογές.
Επειδή αυτό είναι τόσο συνηθισμένο, μπορούμε να αντικαταστήσουμε ολόκληρο αυτό το τμήμα με `-s`, που σημαίνει τυποποιημένη (standard) διάταξη και υπονοεί όλες αυτές τις επιλογές.
Η ακόλουθη εντολή είναι ισοδύναμη:

[source,console]
----
$ git svn clone file:///tmp/test-svn -s
----

Σε αυτό το σημείο, θα πρέπει να έχουμε ένα έγκυρο αποθετήριο Git που έχει εισάγει τους κλάδους και τις ετικέτες μας:

[source,console]
----
$ git branch -a
* master
  remotes/origin/my-calc-branch
  remotes/origin/tags/2.0.2
  remotes/origin/tags/release-2.0.1
  remotes/origin/tags/release-2.0.2
  remotes/origin/tags/release-2.0.2rc1
  remotes/origin/trunk
----

Ας σημειωθεί πώς το εργαλείο διαχειρίζεται τις ετικέτες Subversion ως απομακρυσμένες ref.
(((εντολές git, show-ref)))
Ας ρίξουμε μια πιο προσεκτική ματιά στην εντολή διοχέτευσης `show-ref` του Git :

[source,console]
----
$ git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master
0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk
----

Το Git δεν το κάνει αυτό όταν κλωνοποιεί από έναν διακομιστή Git· παρακάτω φαίνεται με τι μοιάζει ένα αποθετήριο με ετικέτες αμριβώς μετά την κλωνοποίηση:

[source,console]
----
$ git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master
32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0
----

Το Git ανακτά τις ετικέτες κατευθείαν στο φάκελο `refs/tags`, αντί να τις αντιμετωπίζει ως απομακρυσμένους κλάδους.

===== Υποβολή στο Subversion

Τώρα που έχουμε ένα αποθετήριο στο οποίο εργαζόμαστε, μπορούμε να κάνουμε κάποια εργασία στο έργο και να ωθήσουμε τις υποβολές μας προς τα πάνω, ουσιαστικά χρησιμοποιώντας το Git ως πελάτη SVN.
Εάν επεξεργαστούμε ένα από τα αρχεία και το υποβάλουμε, έχουμε μια υποβολή που υπάρχει στο Git τοπικά και δεν υπάρχει στον διακομιστή Subversion:

[source,console]
----
$ git commit -am 'Adding git-svn instructions to the README'
[master 4af61fd] Adding git-svn instructions to the README
 1 file changed, 5 insertions(+)
----

Στη συνέχεια, πρέπει να ωθήσουμε την αλλαγή μας προς τα πάνω.
Αυτό αλλάζει τον τρόπο με τον οποίο εργαζόμαστε με το Subversion --μπορούμε να εκτελέσουμε αρκετές υποβολές τοπικά και στη συνέχεια να τις ωθήσουμε ταυτόχρονα στον διακομιστή Subversion.
Για να ωθήσουμε σε έναν διακομιστή Subversion, εκτελούμε την εντολή `git svn dcommit`:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r77
    M	README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)
No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Αυτό λαμβάνει όλες τις υποβολές που κάναμε πάνω από τον κώδικα του διακομιστή Subversion, πραγματοποιεί μια υποβολή Subversion για καθεμία και μετά ξαναγράφει την τοπική μας υποβολή Git για να συμπεριλάβουμε ένα μοναδικό αναγνωριστικό.
Αυτό είναι σημαντικό επειδή σημαίνει ότι όλα τα αθροίσματα ελέγχου SHA-1 για τις υποβολές μας αλλάζουν.
Εν μέρει για αυτόν τον λόγο, η εργασία με απομακρυσμένες εκδόσεις του έργου μας σε Git ταυτόχρονα με εργασία σε έναν διακομιστή Subversion δεν είναι καλή ιδέα.
Αν κοιτάξουμε την τελευταία υποβολή, μπορούμε να δούμε το νέο `git-svn-id` που προστέθηκε:

[source,console]
----
$ git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Author: ben <ben@0b684db3-b064-4277-89d1-21af03df0a68>
Date:   Thu Jul 24 03:08:36 2014 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68
----

Παρατηρούμε ότι το άθροισμα ελέγχου SHA-1 που ξεκίνησε αρχικά με το `4af61fd` όταν υποβάλαμε τώρα αρχίζει με` 95e0222`.
Αν θέλουμε να ωθήσουμε τόσο σε έναν διακομιστή Git όσο και σε έναν διακομιστή Subversion, πρέπει πρώτα να ωθήσουμε (`dcommit`) στον διακομιστή Subversion, επειδή η ενέργεια αυτή αλλάζει τα δεδομένα της υποβολής μας.

===== Έλξη νέων αλλαγών

Εάν συνεργαζόμαστε με άλλους προγραμματιστές, τότε σε κάποιο σημείο ένας από εμάς θα ωθήσει και μετά κάποιος άλλος θα προσπαθήσει να ωθήσει μια αλλαγή που έρχεται σε σύγκρουση με την πρώτη.
Η αλλαγή αυτή θα απορριφθεί μέχρι να συγχωνεύσουμε την εργασία του.
Στην `git svn`, μοιάζει με αυτό:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt
Current branch master is up to date.
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.
----

Για να επιλύσουμε αυτήν την κατάσταση, μπορούμε να εκτελέσουμε την `git svn rebase`, η οποία καταργεί οποιεσδήποτε αλλαγές στον διακομιστή δεν έχουμε ακόμα και επαντοποθετεί οποιαδήποτε εργασία έχουμε πάνω από αυτό που βρίσκεται στον server:

[source,console]
----
$ git svn rebase
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt
First, rewinding head to replay your work on top of it...
Applying: update foo
Using index info to reconstruct a base tree...
M	README.txt
Falling back to patching base and 3-way merge...
Auto-merging README.txt
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.
----

Τώρα, όλη η δουλειά μας είναι πάνω από αυτό που βρίσκεται στον διακομιστή Subversion, έτσι ώστε να μπορούμε να τρέξουμε `dcommit` με επιτυχία:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r85
    M	README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)
No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Ας σημειωθεί ότι αντίθετα με το Git, το οποίο απαιτεί να συγχωνεύσουμε την εργασία που έχει γίνει upstream και δεν έχουμε ακόμα τοπικά προτού μπορέσουμε να ωθήσουμε, το `git svn` μας επιβάλει να το κάνουμε αυτό μόνο αν οι αλλαγές συγκρούονται (όπως ακριβώς λειτουργεί το Subversion).
Αν κάποιος άλλος ωθήσει μια αλλαγή σε ένα αρχείο και στη συνέχεια ωθήσουμε μια αλλαγή σε άλλο αρχείο, το `dcommit` μας θα λειτουργήσει μια χαρά:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	configure.ac
Committed r87
    M	autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)
    M	configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)
W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh
First, rewinding head to replay your work on top of it...
----

Αυτό είναι σημαντικό να το θυμόμαστε, επειδή το αποτέλεσμα είναι μια κατάσταση του έργου που δεν υπήρχε σε κανέναν από τους υπολογιστές μας όταν ώθησαμε.
Εάν οι αλλαγές είναι ασυμβίβαστες αλλά δεν έρχονται σε σύγκρουση, μπορεί να έχουμε προβλήματα που είναι δύσκολο να διαγνωστούν.
Αυτό είναι διαφορετικό από όταν χρησιμοποιούμε διακομιστή Git --στο Git μπορούμε να ελέγξουμε πλήρως την κατάσταση του πελάτη μας πριν δημοσιεύσουμε, ενώ στο SVN, δεν μπορούμε ποτέ να είμαστε σίγουροι ότι οι καταστάσεις αμέσως πριν και αμέσως μετά την υποβολή είναι πανομοιότυπα.

Θα πρέπει επίσης να εκτελέσουμε αυτήν την εντολή για να έλξουμε αλλαγές από τον διακομιστή Subversion, ακόμη και αν δεν είμαστε έτοιμοι να υποβάλουμε.
Μπορούμε να εκτελέσουμε το `git svn fetch` για να τραβήξουμε τα νέα δεδομένα, αλλά η `git svn rebase` κάνει την ανάκτηση και στη συνέχεια ενημερώνει τις τοπικές υποβολές μας.

[source,console]
----
$ git svn rebase
    M	autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/origin/trunk.
----

Το τρέξιμο της `git svn rebase` κάθε τόσο διασφαλίζει ότι ο κώδικάς μας είναι πάντα ενημερωμένος.
Όμως θα πρέπει να είμαστε σίγουροι ότι ο κατάλογος εργασίας μας είναι καθαρός όταν την εκτελούμε.
Αν έχουμε τοπικές αλλαγές, πρέπει είτε να φυλάξουμε την εργασία μας σε κάποιο απόθεμα είτε να την υποβάλουμε προσωρινά πριν εκτελέσουμε την `git svn rebase` --διαφορετικά, η εντολή θα σταματήσει εάν διαπιστώσει ότι η αλλαγή βάσης θα οδηγήσει σε σύγκρουση συγχώνευσης.

===== Ζητήματα διακλάδωσης στο Git

Όταν εξοικειωθούμε με μια ροή εργασίας του Git, πιθανότατα θα δημιουργήσουμε θεματικούς κλάδους, θα εργαστούμε σε αυτούς και στη συνέχεια θα τους συγχωνεύσουμε.
Αν ωθούμε σε έναν διακομιστή Subversion μέσω της `git svn`, ίσως θελήσουμε να αλλάξουμε τη βάση της εργασίας μας σε έναν κλάδο κάθε φορά αντί να συγχωνεύσουμε τους κλάδους.
Ο λόγος για τον οποίο προτιμάμε την αλλαγή της βάσης είναι ότι το Subversion έχει γραμμικό ιστορικό και δεν αντιμετωπίζει τις συγχωνεύσεις όπως το Git, έτσι η `git svn` ακολουθεί μόνο τον πρώτο γονέα όταν μετατρέπει τα στιγμιότυπα σε υποβολές Subversion.

Ας υποθέσουμε ότι το ιστορικό μας μοιάζει με το ακόλουθο: δημιουργήσαμε έναν κλάδο `experiment`, κάναμε δύο υποβολές και στη συνέχεια τους συγχωνεύσαμε ξανά στον `master`.
Όταν κάνουμε `dcommit`, βλέπουμε την εξής έξοδο:

[source,console]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	CHANGES.txt
Committed r89
    M	CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)
    M	COPYING.txt
    M	INSTALL.txt
Committed r90
    M	INSTALL.txt
    M	COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)
No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Η εκτέλεση της `dcommit` σε έναν κλάδο με συγχωνευμένο ιστορικό λειτουργεί καλά, εκτός από το ότι όταν εξετάζουμε το ιστορικό του έργου Git, δεν έχει ξαναγράψει καμία από τις υποβολές που κάναμε στον κλάδο `experiment` --αντίθετα όλες αυτές οι αλλαγές εμφανίζονται στην έκδοση SVN της μοναδικής υποβολής συγχώνευσης.

Όταν κάποιος άλλος κλωνοποιεί αυτό το έργο, το μόνο που βλέπει είναι ότι η συγχώνευση υποβάλλεται με όλη τη δουλειά που στριμώχνεται σε αυτό, σαν να είχαμε τρέξει `git merge --squash`· δεν βλέπουν τα δεδομένα υποβολής σχετικά με το από πού προήλθε ή πότε υποβλήθηκε.

===== Διακλαδώσεις στο Subversion

Η διακλαδώσεις στο Subversion δεν είναι ίδιες με τις διακλαδώσεις στο Git· αν μπορούμε να αποφύγουμε να τις χρησιμοποιούμε πολύ, αυτό είναι μάλλον το καλύτερο.
Ωστόσο, μπορούμε να δημιουργήσουμε κλάδους και τους υποβάλουμε στο Subversion χρησιμοποιώντας την `git svn`.

===== Δημιουργία νέου κλάδου στο SVN

Για να δημιουργήσουμε έναν νέο κλάδο στο Subversion, εκτελούμε την `git svn branch [όνομα_κλάδου]`:

[source,console]
----
$ git svn branch opera
Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/opera, 90
Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0
Following parent with do_switch
Successfully followed parent
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)
----

Αυτό ισοδυναμεί με την εντολή `svn copy trunk branches/opera` στο Subversion και λειτουργεί στον διακομιστή Subversion.
Είναι σημαντικό να σημειωθεί ότι αυτή η εντολή δεν μας μεταφέρει σε αυτόν τον κλάδο· εάν υποβάλουμε σε αυτό το σημείο, αυτή η υποβολή θα μεταβεί στον `trunk` του διακομιστή, όχι στον `όπερα`.

===== Μετάβαση μεταξύ ενεργών κλάδων

Το Git υπολογίζει σε ποιον κλάδο πηγαίνουν τα dcommit μας αναζητώντας την άκρη όλων των κλάδων Subversion στο ιστορικό μας --θα πρέπει να έχουμε μόνο ένα και θα πρέπει να είναι το τελευταίο με ένα `git-svn-id` στο τρέχον ιστορικό του κλάδου μας.

Εάν θέλουμε να εργαστούμε ταυτόχρονα σε περισσότερους από έναν κλάδους, μπορούμε να ρυθμίσουμε τοπικούς κλάδους να κάνουν `dcommit` σε συγκεκριμένους κλάδους Subversion ξεκινώντας τους στην εισαγόμενη υποβολή Subversion για αυτόν τον κλάδο.
Αν θέλουμε έναν κλάδο `opera` στον οποίο μπορούμε να εργαστούμε ξεχωριστά, μπορούμε να τρέξουμε:

[source,console]
----
$ git branch opera remotes/origin/opera
----

Τώρα, εάν θέλουμε να συγχωνεύσουμε τον κλάδο μας `opera` σε `trunk` (τον κύριο κλάδο μας), μπορούμε να το κάνουμε με μια κανονική `git merge`.
Αλλά πρέπει να δώσουμε ένα περιγραφικό μήνυμα υποβολής (με `-m`), αλλιώς η συγχώνευση θα λέει ``Merge branch opera'' αντί για κάτι χρήσιμο.

Ας θυμηθούμε ότι παρόλο που χρησιμοποιούμε την `git merge` για να κάνουμε αυτήν τη λειτουργία και η συγχώνευση πιθανόν θα είναι πολύ πιο εύκολη από ό,τι θα ήταν στο Subversion (επειδή το Git θα ανιχνεύσει αυτόματα την κατάλληλη βάση συγχώνευσης για μας), αυτή δεν είναι μία κανονική υποβολή συγχώνευσης του Git.
Πρέπει να ωθήσουμε αυτά τα δεδομένα πίσω σε έναν διακομιστή Subversion που δεν μπορεί να χειριστεί μια υποβολή που παρακολουθεί περισσότερους από έναν γονείς· οπότε, αφού τα ωθήσουμε, θα μοιάζει με μια μία μοναδική υποβολή που στρίμωξε όλη τη δουλειά ενός άλλου κλάδου κάτω από μια και μοναδική υποβολή.
Αφού συγχωνεύσουμε έναν κλάδο σε κάποιον άλλο, δεν μπορούμε εύκολα να επιστρέψουμε και να συνεχίσουμε να εργαζόμαστε σε αυτόν τον κλάδο, όπως συνήθως μπορούμε στο Git.
Η εντολή `dcommit` που τρέχουμε διαγράφει κάθε πληροφορία που λέει σε ποιον κλάδο συγχωνεύθηκε, έτσι οι μεταγενέστεροι υπολογισμοί βάσης συγχώνευσης θα είναι λανθασμένοι --η `dcommit` κάνει το αποτέλεσμα `git merge` να μοιάζει σαν να τρέξαμε `git merge --squash`.
Δυστυχώς, δεν υπάρχει κάποιος καλός τρόπος για να αποφύγουμε αυτήν την κατάσταση --το Subversion δεν μπορεί να αποθηκεύσει αυτές τις πληροφορίες, έτσι θα είμαστε πάντα πάντα περιορισμένοι από τους περιορισμούς του, εφόσον το χρησιμοποιούμε στον διακομιστή μας.
Για να αποφύγουμε τα προβλήματα, πρέπει να διαγράψουμε τον τοπικό κλάδο (στην περίπτωση αυτήν τον `opera`) αφού τον συγχωνεύσουμε στον κορμό.

===== Εντολές Subversion 

Το σύνολο εργαλείων `git svn` παρέχει πολλές εντολές για να διευκολύνει τη μετάβαση στο Git παρέχοντας κάποια λειτουργικότητα παρόμοια με αυτήν που είχαμε στο Subversion.
Ακολουθούν μερικές εντολές που μας δίνουν αυτά που έδινε το Subversion.

====== Μορφή ιστορικού στο SVN

Αν είμαστε συνηθισμένοι στο Subversion και θέλουμε να δούμε το ιστορικό μας σε στυλ SVN, μπορούμε να εκτελέσουμε την `git svn log` για να δούμε το ιστορικό των εργασιών μας σε μορφή SVN:

[source,console]
----
$ git svn log
------------------------------------------------------------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines

Merge branch 'experiment'

------------------------------------------------------------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines

updated the changelog
----

Θα πρέπει να γνωρίζουμε δύο σημαντικά πράγματα για την `git svn log`.
Πρώτον, λειτουργεί εκτός σύνδεσης, σε αντίθεση με την πραγματική εντολή `svn log`, η οποία ζητάει από τον διακομιστή Subversion τα δεδομένα.
Δεύτερον, δείχνει μόνο υποβολές που έχουν υποβληθεί στον διακομιστή Subversion.
Τοπικές υποβολές του Git που δεν τις έχουμε κάνει dcommit ακόμα δεν εμφανίζονται· ούτε οι υποβολές που έχουν κάνει άλλοι στον διακομιστή Subversion στο μεταξύ.
Είναι περισσότερο σαν την τελευταία γνωστή κατάσταση των υποβολων στον διακομιστή Subversion.

====== Επισημειώσεις στο SVN 

Καθώς η εντολή `git svn log` προσομοιώνει την εντολή `svn log` εκτός σύνδεσης, μπορούμε να πάρουμε το ισοδύναμο της `svn annotate` εκτελώντας την `git svn blame [αρχείο]`.
Η έξοδος μοιάζει ως εξής:

[source,console]
----
$ git svn blame README.txt
 2   temporal Protocol Buffers - Google's data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal
----

Και πάλι, δεν δείχνει υποβολές που κάναμε τοπικά στο Git ή που έχουν ωθηθεί στο Subversion εν τω μεταξύ.

====== Πληροφορίες διακομιστή SVN

Μπορούμε επίσης να αποκτήσουμε το ίδιο είδος πληροφορίας που μας δίνει η `svn info`, τρέχοντας την `git svn info`:

----
$ git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)
----

Αυτό είναι σαν τις `blame` και `log` στο ότι εκτελείται εκτός σύνδεσης και είναι ενημερωμένο μόνο μέχρι την τελευταία φορά που επικοινωνήσαμε με τον διακομιστή Subversion.

====== Παράβλεψη των παραβλέψεων του Subversion

Αν κλωνοποιήσουμε ένα αποθετήριο Subversion που έχει τις ιδιότητες `svn:ignore` που ορίζουμε οπουδήποτε, πιθανότατα θέλουμε να ορίσουμε αντίστοιχα αρχεία `.gitignore` έτσι ώστε να μην υποβάλουμε κατά λάθος αρχεία που δεν θα έπρεπε.
Η `git svn` έχει δύο εντολές για να βοηθήσει με αυτό το πρόβλημα.
Η πρώτη είναι η `git svn create-ignore`, η οποία δημιουργεί αυτόματα τα αντίστοιχα αρχεία `.gitignore` για μας, έτσι ώστε η επόμενη υποβολή να τα συμπεριλάβει.

Η δεύτερη εντολή είναι η `git svn show-ignore`, η οποία εκτυπώνει στην stdout τις γραμμές που πρέπει να βάλουμε σε ένα αρχείο `.gitignore` ώστε να μπορούμε να ανακατευθύνουμε την έξοδο στο αρχείο εξαιρέσεων του έργου:

[source,console]
----
$ git svn show-ignore > .git/info/exclude
----

Με αυτόν τον τρόπο, δεν γεμίζουμε το έργο με αρχεία `.gitignore`.
Αυτή είναι μια καλή επιλογή αν είμαστε ο μόνος χρήστης Git σε μια ομάδα Subversion και οι συνεργάτες μας δεν θέλουν αρχεία `.gitignore` στο έργο.

===== Περίληψη Git-SVN 

Τα εργαλεία `git svn` είναι χρήσιμα αν είμαστε κολλημένοι με έναν διακομιστή Subversion ή βρισκόμαστε σε περιβάλλον ανάπτυξης που απαιτεί τη χρήση διακομιστή Subversion.
Θα πρέπει να το δούμε σαν σακατεμένο Git αλλιώς θα συνατήσουμε ζητήματα στη μετάφραση από το ένα σύστημα στο άλλο που μπορεί να μπερδέψουν εμάς και τους συνεργάτες μας.
Για να αποφύγουμε τα προβλήματα, καλό είναι να ακολουθούμε αυτές τις οδηγίες:

* Διατηρούμε ένα γραμμικό ιστορικό Git που δεν περιέχει υποβολές συγχώνευσης που έγιναν με την `git merge`.
  Κάθε εργασία που κάνουμε έξω από τον κλάδο της κύριας γραμμής την _επανατοποθετούμε_ ξανά σε αυτήν (αλλάζουμε τη βάση της στην κύρια γραμμή)· δεν τη συγχωνεύουμε.
* Δεν εγκαθιστούμε και συνεργαζόμαστε σε ξεχωριστό διακομιστή Git.
  Ενδεχομένως έχουμε έναν για να επιταχύνουμε τους κλώνους για νέους προγραμματιστές, αλλά δεν ωθούμε τίποτα σε αυτόν που δεν έχει καταχώρηση `git-svn-id`.
  Ίσως ακόμα θελήσουμε να προσθέσουμε ένα άγκιστρο `pre-receive` που ελέγχει κάθε μήνυμα αποστολής για ένα `git-svn-id` και απορρίπτει ωθήσεις που περιέχουν υποβολές χωρίς αυτό.

Εάν ακολουθήσουμε αυτές τις οδηγίες, η συνεργασία με έναν διακομιστή Subversion μπορεί να είναι πιο ανεκτή.
Ωστόσο, αν είναι δυνατό να μετακινηθούμε σε έναν πραγματικό διακομιστή Git, αυτό θα ωφελήσει πολυ πολύ περισσότερο την ομάδα μας.

