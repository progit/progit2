[[_an_example_git_enforced_policy]]
=== An Example Git-Enforced Policy

(((policy example)))
In this section, you use what you've learned to establish a Git workflow that checks for a custom
commit message format, and allows only certain users to modify certain subdirectories in a project.
You build client scripts that help the developer know if their push is rejected and
server scripts that actually enforce the policies.

The scripts we show are written in Ruby, partly because of intellectual inertia, but also
because Ruby is easy to read, even if you can't write it.
However, any language works. All the sample hook scripts distributed with Git are in either Perl or Bash,
so you can see plenty of examples of hooks in those languages by looking at the samples.

==== Server-Side Hook

All the server-side work goes into the `update` file in your `hooks` directory.
The `update` hook runs once per branch being pushed and takes the following three arguments:

* The name of the reference being pushed to
* The branch's old revision
* The new revision being pushed

You also have access to the username of the user doing the pushing if the push is being run over SSH.
If you've allowed everyone to connect using a single username (like `git`) via public-key authentication,
you may have to give that user a shell wrapper that determines which user is actually connecting based
on the public key, and set an environment variable accordingly.
Here we assume the connecting username is in the `$USER` environment variable,
so your update script begins by gathering all the information you need.

[source,ruby]
----
#!/usr/bin/env ruby

$refname = ARGV[0]
$oldrev  = ARGV[1]
$newrev  = ARGV[2]
$user    = ENV['USER']

puts "Enforcing Policies..."
puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"
----

Yes, those are global variables.
Don't judge â€“ it's easier to demonstrate this way.

[[_enforcing_commit_message_format]]
===== Enforcing a Specific Commit-Message Format

Your first challenge is to enforce a format that each commit message must adhere to.
Just to have a target, assume that each message must include a string that looks like `ref: 1234` because
you want each commit to link to an item in your ticketing system.
You must look at each commit being pushed, see if the required string is in the commit message, and,
if the string is absent from any of the commits, exit non-zero so the push is rejected.

You can get a list of the hashes of all the commits that are being pushed by taking
the `$newrev` and `$oldrev` values and passing them to the plumbing command `git rev-list`.
This is basically the same output as that produced by `git log`, but by default it shows only the
hashes and no other information.
So, to get a list of all the commit SHA-1 hashes introduced between one commit and another, run

[source,console]
----
$ git rev-list 538c33..d14fc7
d14fc7c847ab946ec39590d87783c69b031bdfb7
9f585da4401b0a3999e84113824d15245c13f0be
234071a1be950e2a8d078e6141f5cd20c1e61ad3
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475
----

You can take that output, loop through each of those commit hashes, grab the message for it, and test that message against a regular expression that looks for a pattern.

You have to figure out how to get the commit message from each of these commits to test.
To get the raw commit data, you can use another plumbing command called `git cat-file`.
We go over all these plumbing commands in detail in <<ch10-git-internals#ch10-git-internals>> but for now,
here's what that command shows.

[source,console]
----
$ git cat-file commit ca82a6
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon <schacon@gmail.com> 1205815931 -0700
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

Change the version number
----

A simple way to get the commit message from a commit when you have its hash is to go to
the first blank line and take everything after that.
You can do this by running the `sed` command on Unix systems.

[source,console]
----
$ git cat-file commit ca82a6 | sed '1,/^$/d'
Change the version number
----

You can use that command to grab the commit message from each commit that's being pushed and exit
if you see anything that doesn't match. To exit the script and reject the push, exit non-zero.
The whole method looks like

[source,ruby]
----
$regex = /\[ref: (\d+)\]/

# enforced custom commit message format
def check_message_format
  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  missed_revs.each do |rev|
    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
    if !$regex.match(message)
      puts "[POLICY] Your message is not formatted correctly"
      exit 1
    end
  end
end
check_message_format
----

Putting that in your `update` script rejects updates that contain commits that have messages
that don't adhere to your message formatting rule.

===== Enforcing a User-Based ACL System

Suppose you want to add a mechanism that uses an access control list (ACL) to specify which users are allowed
to push changes to certain parts of your projects. Some people have full access, and others can only push
changes to certain subdirectories or specific files.
To enforce this, put those rules in a file named `acl` in your bare Git repository on the server.
Have the `update` hook look at those rules, see what files are being introduced in all
the commits being pushed, and determine whether the user doing the push is allowed to update all those files.

The first thing to do is write your ACL.
Here you use a format very much like the CVS ACL mechanism. The format uses a series of lines,
where the first field is `avail` or `unavail`, the next field is a comma-delimited list of the
users to which the rule applies, and the last field is the path to which the rule applies
(blank meaning open access).
All of these fields are delimited by vertical bar (`|`) characters.

In this case, you have a couple of administrators, some documentation writers with access to
the `doc` directory, and one developer who only has access to the `lib` and `tests` directories.
Your ACL file looks like

[source]
----
avail|nickh,pjhyett,defunkt,tpw
avail|usinclair,cdickens,ebronte|doc
avail|schacon|lib
avail|schacon|tests
----

Begin by reading this data into a structure.
In this case, to keep the example simple, only enforce the `avail` directives.
Here's a method that gives an associative array where the key is the user name and the value
is an array of paths to which the user has write access.

[source,ruby]
----
def get_acl_access_data(acl_file)
  # read in ACL data
  acl_file = File.read(acl_file).split("\n").reject { |line| line == '' }
  access = {}
  acl_file.each do |line|
    avail, users, path = line.split('|')
    next unless avail == 'avail'
    users.split(',').each do |user|
      access[user] ||= []
      access[user] << path
    end
  end
  access
end
----

In the ACL file you looked at earlier, this `get_acl_access_data` method returns a data structure that
looks like

[source,ruby]
----
{"defunkt"=>[nil],
 "tpw"=>[nil],
 "nickh"=>[nil],
 "pjhyett"=>[nil],
 "schacon"=>["lib", "tests"],
 "cdickens"=>["doc"],
 "usinclair"=>["doc"],
 "ebronte"=>["doc"]}
----

Now that you have the permissions sorted out, determine what paths the commits being pushed have
modified, so you can make sure the user who's pushing has access to all of them.

You can pretty easily see what files have been modified in a single commit by adding the `--name-only`
option to `git log` (mentioned briefly in <<ch02-git-basics-chapter#ch02-git-basics-chapter>>).

[source,console]
----
$ git log -1 --name-only --pretty=format:'' 9f585d

README
lib/test.rb
----

If you use the ACL structure returned from the `get_acl_access_data` method and check it against the listed files in each of the commits, you determine whether the user has access to push all of their commits:

[source,ruby]
----
# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('acl')

  # see if anyone is trying to push something they can't
  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  new_commits.each do |rev|
    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split("\n")
    files_modified.each do |path|
      next if path.size == 0
      has_file_access = false
      access[$user].each do |access_path|
        if !access_path  # user has access to everything
           || (path.start_with? access_path) # access to this path
          has_file_access = true
        end
      end
      if !has_file_access
        puts "[POLICY] You do not have access to push to #{path}"
        exit 1
      end
    end
  end
end

check_directory_perms
----

You get a list of new commits being pushed to your server with `git rev-list`.
Then, for each of those commits, find which files are modified and make sure the user who's pushing has access to all the paths being modified.

Now your users can't push any commits with badly formed messages or with modified files outside of their designated paths.

===== Testing It Out

If you run `chmod u+x .git/hooks/update`, which is the file into which you should have put all this code, and then try to push a commit with a non-compliant message, you get something like

[source,console]
----
$ git push -f origin master
Counting objects: 5, done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 323 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
Enforcing Policies...
(refs/heads/master) (8338c5) (c5b616)
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
To git@gitserver:project.git
 ! [remote rejected] master -> master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
----

There are a couple of interesting things here.
First, you see the hook start running.

[source,console]
----
Enforcing Policies...
(refs/heads/master) (fb8c72) (c56860)
----

Remember that you printed that at the very beginning of your update script.
Anything your script echoes to `stdout` is transferred to the client.

The next thing you notice is the error message.

[source,console]
----
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
----

The first line was printed by you, the other two were from Git telling you that the update script exited non-zero and that your push is being declined.

Lastly, you have this:

[source,console]
----
To git@gitserver:project.git
 ! [remote rejected] master -> master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
----

You see a remote reject message for each reference that your hook declined,
saying that it was declined specifically because of a hook failure.

Furthermore, if someone tries to edit a file they don't have access to and push a commit containing it,
they see something similar. For instance, if a documentation author tries to push a commit
modifying something in the `lib` directory, they see

[source,console]
----
[POLICY] You do not have access to push to lib/test.rb
----

From now on, as long as that `update` script is present and executable, your repository will never have a commit message without your pattern in it.

==== Client-Side Hooks

The downside to this approach is the whining that inevitably results when your users' commit
pushes are rejected. Having their carefully crafted work rejected at the last minute can be extremely
frustrating and confusing. Furthermore, they have to edit their history to correct it,
which isn't always for the faint of heart.

The answer to this dilemma is to provide client-side hooks that notify users when they're doing
something that the server is likely to reject. That way, the users can correct any problems before
committing and before those issues become more difficult to fix. Because hooks aren't transferred when
a project is cloned, you must distribute these scripts some other way and then have your users copy
them to their `.git/hooks` directory and make them executable.
You can distribute these hooks within the project or in a separate project,
but Git doesn't get them automatically.

To begin, check your commit message just before each commit is recorded,
so you know the server isn't going to reject your changes due to badly formatted commit messages.
To do this, add the `commit-msg` hook.
If it reads the message from the file passed as the first argument and compares it to the required pattern,
you can force Git to abort the commit if there's no match.

[source,ruby]
----
#!/usr/bin/env ruby
message_file = ARGV[0]
message = File.read(message_file)

$regex = /\[ref: (\d+)\]/

if !$regex.match(message)
  puts "[POLICY] Your message is not formatted correctly"
  exit 1
end
----

If that script is in place (in `.git/hooks/commit-msg`) and executable, and you commit with a message that isn't properly formatted, you see

[source,console]
----
$ git commit -am 'Test'
[POLICY] Your message is not formatted correctly
----

No commit was completed.
However, if your message contains the proper pattern, Git allows the commit.

[source,console]
----
$ git commit -am 'Test [ref: 132]'
[master e05c914] Test [ref: 132]
 1 file changed, 1 insertions(+), 0 deletions(-)
----

Next, make sure you aren't modifying files that aren't allowed by your ACL.
If your project's `.git` directory contains a copy of the ACL file you used previously,
then the following `pre-commit` script enforces those constraints:

[source,ruby]
----
#!/usr/bin/env ruby

$user    = ENV['USER']

# [ insert acl_access_data method from above ]

# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('.git/acl')

  files_modified = `git diff-index --cached --name-only HEAD`.split("\n")
  files_modified.each do |path|
    next if path.size == 0
    has_file_access = false
    access[$user].each do |access_path|
    if !access_path || (path.index(access_path) == 0)
      has_file_access = true
    end
    if !has_file_access
      puts "[POLICY] You do not have access to push to #{path}"
      exit 1
    end
  end
end

check_directory_perms
----

This is roughly the same script as the server-side part, but with two important differences.
First, the ACL file is in a different place, because this script runs from your working directory, not from your `.git` directory.
You have to change the path to the ACL file from

[source,ruby]
----
access = get_acl_access_data('acl')
----

to this.

[source,ruby]
----
access = get_acl_access_data('.git/acl')
----

The other important difference is the way you get a listing of the changed files.
Because the server-side method looks at the log of commits, and, at this point, the commit
hasn't been recorded yet, you must get your changed file list from the staging area instead.
Instead of

[source,ruby]
----
files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`
----

you have to use

[source,ruby]
----
files_modified = `git diff-index --cached --name-only HEAD`
----

But those are the only two differences â€“ otherwise, the script works the same way.
One caveat is that it expects you to be running locally as the same user you push as.
If this isn't true, you must set the `$USER` environment variable manually.

One other thing we can do here is make sure the user doesn't push non-fast-forwarded references.
To get a reference that isn't a fast-forward, you either have to rebase past a commit you've already pushed or try pushing a different local branch to the same remote branch.

Presumably, the server is already configured with `receive.denyDeletes` and `receive.denyNonFastForwards` to enforce this policy, so the only accidental thing you can try to catch is rebasing commits that have already been pushed.

Here's an example pre-rebase script that checks for that.
It gets a list of all the commits you're about to rewrite and checks whether they exist in any of
your remote references. If it sees one that's reachable from one of your remote references,
it aborts the rebase.

[source,ruby]
----
#!/usr/bin/env ruby

base_branch = ARGV[0]
if ARGV[1]
  topic_branch = ARGV[1]
else
  topic_branch = "HEAD"
end

target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split("\n")
remote_refs = `git branch -r`.split("\n").map { |r| r.strip }

target_shas.each do |sha|
  remote_refs.each do |remote_ref|
    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
    if shas_pushed.split("\n").include?(sha)
      puts "[POLICY] Commit #{sha} has already been pushed to #{remote_ref}"
      exit 1
    end
  end
end
----

This script uses a syntax that wasn't covered in <<ch07-git-tools#_revision_selection>>.
You get a list of commits that have already been pushed by running

[source,ruby]
----
`git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
----

The `sha^@` syntax resolves to all the parents of that commit.
You're looking for any commit that's reachable from the last commit on the remote that isn't
reachable from any parent of any of the hash you're trying to push up -- meaning it's a fast-forward.

The main drawback to this approach is that it can be very slow and is often unnecessary.
If you don't try to force the push with `-f`, the server warns you and doesn't accept the push.
However, it's an interesting exercise and can in theory help avoid a rebase that you might later
have to go back and fix.
